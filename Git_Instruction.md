![git.0-1024x638.jpg](git.0-1024x683.jpg)
# Работа с Git.

## 1. Проверка наличия установленного Git.

В терминале выполнить команду `git version`.
Если **Git** установлен, появится сообщение с информацией о версии программы. Иначе будет сообщение об ошибке.

## 2. Установка Git.
Загружаем последнюю версию **Git** с [сайта](https://git-scm.com/downloads) или сайта https://git-scm.com/downloads 

## 3. Настройка Git.
При первом использовании **Git** необходимо представиться. Для этого нужно ввести в терминале две команды:
```
git config --global user.name "Ваше имя"
git config --global user.email "Ваш email"
```
## 4. Создание Git-репозитория.
Для создания **Git-репозитория** вы можете использовать два основных подхода. Во-первых,
импорт в **Git** уже существующего проекта или директории. Во-вторых, клонирование
существующего репозитория с другого сервера.
### `Создание репозитория в существующей директории`
Если вы собираетесь начать использовать **Git** для существующего проекта, то вам
необходимо перейти в директорию проекта и в командной строке ввести
```
 git init
```
Эта команда создаёт в текущей директории новую поддиректорию с именем `.git`,
содержащую все необходимые файлы репозитория — основу **Git-репозитория**. На этом этапе
ваш проект ещё не находится под версионным контролем. 
Если вы хотите добавить под версионный контроль существующие файлы (в отличие от
пустого каталога), вам стоит добавить их в индекс и осуществить первый коммит
изменений. Добиться этого вы сможете запустив команду `git add` несколько раз, указав
индексируемые файлы, а затем выполнив `git commit`:
```
git add *.c
git add LICENSE
git commit -m 'initial project version'
```
Мы разберем, что делают эти команды чуть позже. Теперь у вас есть **Git-репозиторий** с
отслеживаемыми файлами и начальным коммитом.
### `Клонирование существующего репозитория`
Для получения копии существующего **Git-репозитория**, например, проекта, в который вы
хотите внести свой вклад, необходимо использовать команду `git clone`. Если вы знакомы с другими системами контроля версий, такими как *Subversion*, то заметите, что команда
называется `"clone"`, а не `"checkout"`. Это важное различие – вместо того, чтобы просто
получить рабочую копию, **Git** получает копию практически всех данных, которые есть на
сервере. При выполнении `git clone` с сервера забирается `(pulled)` каждая версия каждого
файла из истории проекта. Фактически, если серверный диск выйдет из строя, вы можете
использовать любой из клонов на любом из клиентов, для того, чтобы вернуть сервер в то
состояние, в котором он находился в момент клонирования (вы можете потерять часть
серверных перехватчиков `(server-side hooks)` и т.п., но все данные, помещённые под
версионный контроль, будут сохранены.

Клонирование репозитория осуществляется командой `git clone` [url]. Например, если вы
хотите клонировать библиотеку `libgit2`, вы можете сделать это следующим образом:
```
git clone https://github.com/libgit2/libgit2
 ```
 Эта команда создаёт директорию `“libgit2”`, инициализирует в ней поддиректорию `.git`,
скачивает все данные для этого репозитория и создаёт `(checks out)` рабочую копию
последней версии. Если вы зайдёте в новую директорию `libgit2`, то увидите в ней файлы
проекта, готовые для работы или использования. Для того, чтобы клонировать репозиторий
в директорию с именем, отличающимся от `“libgit2”`, необходимо указать желаемое имя, как
параметр командной строки:
```
git clone https://github.com/libgit2/libgit2 mylibgit
```
Эта команда делает всё то же самое, что и предыдущая, только результирующий каталог
будет назван `mylibgit`.

В **Git’е** реализовано несколько транспортных протоколов, которые вы можете использовать.
В предыдущем примере использовался протокол `https://`, вы также можете встретить `git://`
или `user@server:path/to/repo.git`, использующий протокол передачи `SSH`. 
**Git** на сервер мы познакомимся со всеми доступными вариантами конфигурации сервера
для обеспечения доступа к вашему **Git-репозиторию**, а также рассмотрим их достоинства и
недостатки.

# 5. Запись изменений в репозиторий 
Итак, у вас имеется настоящий **Git-репозиторий** и рабочая копия файлов для некоторого
проекта. Вам нужно делать некоторые изменения и фиксировать `“снимки”` состояния
`(snapshots)` этих изменений в вашем репозитории каждый раз, когда проект достигает
состояния, которое вам хотелось бы сохранить.
Запомните, каждый файл в вашем рабочем каталоге может находиться в одном из двух
состояний: под версионным контролем `(отслеживаемые)` и нет `(неотслеживаемые)`.
`Отслеживаемые файлы` — это те файлы, которые были в последнем слепке состояния
проекта `(snapshot)`; они могут быть *неизменёнными, изменёнными или подготовленными* к коммиту `(staged)`. `Неотслеживаемые файлы` — это всё остальное, любые файлы в вашем
рабочем каталоге, которые не входили в ваш последний слепок состояния и не
подготовлены к коммиту. Когда вы впервые клонируете репозиторий, все файлы будут
отслеживаемыми и неизменёнными, потому что вы только взяли их из хранилища `(checked
them out)` и ничего пока не редактировали.

Как только вы отредактируете файлы, **Git** будет рассматривать их как изменённые, т.к. вы
изменили их с момента последнего коммита. Вы индексируете `(stage)` эти изменения и
затем фиксируете все индексированные изменения, а затем цикл повторяется.

### `Определение состояния файлов`
Основной инструмент, используемый для определения, какие файлы в каком состоянии
находятся — это команда `git status`. Если вы выполните эту команду сразу после
клонирования, вы увидите что-то вроде этого:
```
git status
On branch master
nothing to commit, working directory clean
```
Это означает, что у вас чистый рабочий каталог, другими словами – в нем нет
отслеживаемых измененных файлов. **Git** также не обнаружил неотслеживаемых файлов, в
противном случае они бы были перечислены здесь. Наконец, команда сообщает вам на
какой ветке вы находитесь и сообщает вам, что она не расходится с веткой на сервере. Пока
что это всегда ветка `master`, ветка по умолчанию; в этой главе это не важно. В
Ветвление в **Git** будут рассмотрены ветки и ссылки более детально.
Предположим, вы добавили в свой проект новый файл, простой файл `README`. Eсли этого
файла раньше не было, и вы выполните `git status`, вы увидите свой неотслеживаемый файл
вот так:
```
echo 'My Project' > README              git status
On branch master
Untracked files:
  (use "git add <file>..." to include in what will be committed)
  README
nothing added to commit but untracked files present (use "git add" to track)
```
Понять, что новый файл `README` неотслеживаемый можно по тому, что он находится в
секции `Untracked files` в выводе команды ``status``. Статус `Untracked files`, по сути,
означает, что **Git** видит файл, отсутствующий в предыдущем снимке состояния (коммите);
**Git** не станет добавлять его в ваши коммиты, пока вы его явно об этом не попросите. Это
предохранит вас от случайного добавления в репозиторий сгенерированных бинарных
файлов или каких-либо других, которые вы и не думали добавлять. Мы хотели добавить
`README`, так давайте сделаем это.

### `Отслеживание новых файлов`
Для того чтобы начать отслеживать (добавить под версионный контроль) новый файл,
используется команда `git add`. Чтобы начать отслеживание файла `README`, вы можете
выполнить следующее:
```
git add README
```
Если вы снова выполните команду `status`, то увидите, что файл `README` теперь
отслеживаемый и индексированный:

```
git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)
  new file: README
```
Вы можете видеть, что файл проиндексирован по тому, что он находится в секции
`Changes to be committed`. Если вы выполните коммит в этот момент, то версия файла,
существовавшая на момент выполнения вами команды `git add`, будет добавлена в историю
снимков состояния. Как вы помните, когда вы ранее выполнили `git init`, затем вы
выполнили `git add` (файлы) — это было сделано для того, чтобы добавить файлы в вашем
каталоге под версионный контроль. Команда `git add` принимает параметром путь к файлу
или каталогу, если это каталог, команда рекурсивно добавляет (индексирует) все файлы в
данном каталоге.
### `Индексация изменённых файлов`
Давайте модифицируем файл, уже находящийся под версионным контролем. Если вы
измените отслеживаемый файл `CONTRIBUTING.md` и после этого снова выполните
команду `git status`, то результат будет примерно следующим:
```
git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)
  new file: README
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)
  modified: CONTRIBUTING.md
  ```
  Файл ``CONTRIBUTING.md`` находится в секции ``Changes not staged for commit`` — это
означает, что отслеживаемый файл был изменён в рабочем каталоге, но пока не
проиндексирован. Чтобы проиндексировать его, необходимо выполнить команду `git add`.
Это многофункциональная команда, она используется для добавления под версионный
контроль новых файлов, для индексации изменений, а также для других целей, например
для указания файлов с исправленным конфликтом слияния. Вам может быть понятнее,
если вы будете думать об этом как `добавить этот контент в следующий коммит`, а не
как `добавить этот файл в проект`. Выполним `git add`, чтобы проиндексировать
`CONTRIBUTING.md`, а затем снова выполним `git status`:
```
git add CONTRIBUTING.md                 git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)
  new file: README
  modified: CONTRIBUTING.md
  ```
Теперь оба файла проиндексированы и войдут в следующий коммит. В этот момент вы,
предположим, вспомнили одно небольшое изменение, которое вы хотите сделать в
``CONTRIBUTING.md`` до коммита. Вы открываете файл, вносите и сохраняете
необходимые изменения и вроде бы готовы к коммиту. Но давайте-ка ещё раз выполним `git
status`:
```
vim CONTRIBUTING.md                   git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)
  new file: README
  modified: CONTRIBUTING.md
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)
  modified: CONTRIBUTING.md
```
Что за чёрт? Теперь ``CONTRIBUTING.md`` отображается как проиндексированный и непроиндексированный одновременно. Как такое возможно? Такая ситуация наглядно
демонстрирует, что **Git** индексирует файл в точности в том состоянии, в котором он
находился, когда вы выполнили команду `git add`. Если вы выполните коммит сейчас, то
файл ``CONTRIBUTING.md`` попадёт в коммит в том состоянии, в котором он находился,
когда вы последний раз выполняли команду `git add` , а не в том, в котором он находится в
вашем рабочем каталоге в момент выполнения `git commit`. Если вы изменили файл после
выполнения `git add`, вам придётся снова выполнить `git add`, чтобы проиндексировать
последнюю версию файла:
```
git add CONTRIBUTING.md
git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)
  new file: README
  modified: CONTRIBUTING.md
```
### `Сокращенный вывод статуса`
Вывод команды `git status` довольно всеобъемлющий и многословный. **Git** также имеет флаг
вывода сокращенного статуса, так что вы можете увидеть изменения в более компактном
виде. Если вы выполните `git status -s` или `git status --short` вы получите гораздо более
упрощенный вывод.
```
git status -s
 M README
MM Rakefile
A lib/git.rb
M lib/simplegit.rb
?? LICENSE.txt
```
Новые, неотслеживаемые файлы помечены `??` слева от них, файлы добавленные в
отслеживаемые помечены `A`, отредактированные файлы помечены `M` и так далее. В выводе
содержится два столбца - в левом указывается статус файла, а в правой модифицирован ли
он после этого. К примеру в нашем выводе, файл `README` модифицирован в рабочей
директории и не проиндексирован, файл `lib/simplegit.rb` модифицирован и
проиндексирован. Файл `Rakefile` модифицирован, проиндексирован и ещё раз
модифицирован, таким образом на данный момент у него есть изменения которые попадут
в коммит и те которые не попадут.
### `Игнорирование файлов`
Зачастую, у вас имеется группа файлов, которые вы не только не хотите автоматически
добавлять в репозиторий, но и видеть в списках неотслеживаемых. К таким файлам обычно
относятся автоматически генерируемые файлы (различные логи, результаты сборки
программ и т.п.). В таком случае, вы можете создать файл `.gitignore.` с перечислением
шаблонов соответствующих таким файлам. Вот пример файла `.gitignore`:
```
cat .gitignore
*.[oa]
*~
```
Первая строка предписывает **Git** игнорировать любые файлы заканчивающиеся на ``.o``
или ``.a`` - объектные и архивные файлы, которые могут появиться во время сборки кода.
Вторая строка предписывает игнорировать все файлы заканчивающиеся на тильду `(~)`,
которая используется во многих текстовых редакторах, например `Emacs`, для обозначения
временных файлов. Вы можете также включить каталоги `log, tmp` или `pid`; автоматически
создаваемую документацию; и т.д. и т.п. Хорошая практика заключается в настройке файла
`.gitignore` до того, как начать серьёзно работать, это защитит вас от случайного добавления
в репозиторий файлов, которых вы там видеть не хотите.
К шаблонам в файле `.gitignore` применяются следующие правила:
• Пустые строки, а также строки, начинающиеся с `#`, игнорируются.
• Можно использовать стандартные `glob шаблоны`.
• Можно начать шаблон символом слэша `(/)` чтобы избежать рекурсии.
• Можно заканчивать шаблон символом слэша `(/)` для указания каталога.
• Можно инвертировать шаблон, использовав восклицательный знак `(!)` в качестве
первого символа.

`Glob-шаблоны` представляют собой упрощённые регулярные выражения, используемые
командными интерпретаторами. Символ `(*)` соответствует 0 или более символам;
последовательность `[abc]` — любому символу из указанных в скобках `(в данном примере a,
b или c)`; знак вопроса `(?)` соответствует одному символу; и квадратные скобки, в которые
заключены символы, разделённые дефисом (`[0-9]`), соответствуют любому символу из
интервала (в данном случае от 0 до 9). Вы также можете использовать две звёздочки, чтобы
указать на вложенные директории: `a/**/z соответствует a/z, a/b/z, a/b/c/z`, и так далее.
Вот ещё один пример файла `.gitignore`:
```
# no .a files
*.a
# but do track lib.a, even though you're ignoring .a files above
!lib.a
# only ignore the root TODO file, not subdir/TODO
/TODO
# ignore all files in the build/ directory
build/
# ignore doc/notes.txt, but not doc/server/arch.txt
doc/*.txt
# ignore all .txt files in the doc/ directory
doc/**/*.txt
```
TIP
**GitHub** поддерживает довольно полный список примеров `.gitignore` файлов для
множества проектов и языков https://github.com/github/gitignore это может стать
отправной точкой для `.gitignore` в вашем проекте.
### `Просмотр индексированных и неиндексированных изменений`
Если результат работы команды `git status` недостаточно информативен для вас — вам
хочется знать, что конкретно поменялось, а не только какие файлы были изменены — вы
можете использовать команду `git diff`. Позже мы рассмотрим команду `git diff` подробнее;
вы, скорее всего, будете использовать эту команду для получения ответов на два вопроса:
что вы изменили, но ещё не проиндексировали, и что вы проиндексировали и собираетесь
фиксировать. Если `git status` отвечает на эти вопросы в самом общем виде, перечисляя
имена файлов, `git diff` показывает вам непосредственно добавленные и удалённые строки
— собственно заплатку (patch).
Допустим, вы снова изменили и проиндексировали файл `README`, а затем изменили файл
`CONTRIBUTING.md` без индексирования. Если вы выполните команду `git status`, вы опять
увидите что-то вроде:
```
git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)
  new file: README
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)
  modified: CONTRIBUTING.md
```
Чтобы увидеть, что же вы изменили, но пока не проиндексировали, наберите `git diff` без
аргументов:
```
git diff
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 8ebb991..643e24f 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -65,7 +65,8 @@ branch directly, things can get messy.
 Please include a nice description of your changes when you submit your PR;
 if we have to read the whole diff to figure out why you're contributing
 in the first place, you're less likely to get feedback and have your change
-merged in.
+merged in. Also, split your changes into comprehensive chunks if you patch is
+longer than a dozen lines.
 If you are starting to work on a particular area, feel free to submit a PR
 that highlights your work in progress (and note in the PR title that it's
```
Эта команда сравнивает содержимое вашего рабочего каталога с содержимым индекса.
Результат показывает ещё не проиндексированные изменения.
Если вы хотите посмотреть, что вы проиндексировали и что войдёт в следующий коммит,
вы можете выполнить `git diff --staged`. Эта команда сравнивает ваши индексированные
изменения с последним коммитом:
```
git diff --staged
diff --git a/README b/README
new file mode 100644
index 0000000..03902a1
--- /dev/null
+++ b/README
@@ -0,0 +1 @@
+My Project
```
Важно отметить, что `git diff` сама по себе не показывает все изменения сделанные с
последнего коммита — только те, что ещё не проиндексированы. Такое поведение может
сбивать с толку, так как если вы проиндексируете все свои изменения, то `git diff` ничего не
вернёт.
Другой пример: вы проиндексировали файл `CONTRIBUTING.md` и затем изменили его, вы
можете использовать `git diff` для просмотра как индексированных изменений в этом
файле, так и тех, что пока не проиндексированы. В нашем случае это будет выглядеть вот
так:
```
 git add CONTRIBUTING.md
 echo 'test line' >> CONTRIBUTING.md
 git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)
  modified: CONTRIBUTING.md
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)
  modified: CONTRIBUTING.md
```
Теперь вы можете используя `git diff` посмотреть непроиндексированные изменения 
```
git diff
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 643e24f..87f08c8 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -119,3 +119,4 @@ at the
 ## Starter Projects
 See our [projects
list](https://github.com/libgit2/libgit2/blob/development/PROJECTS.md).
+# test line
```
а также уже проиндексированные, используя `git diff --cached (--staged и --cached
синонимы)`:
```
git diff --cached
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 8ebb991..643e24f 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -65,7 +65,8 @@ branch directly, things can get messy.
 Please include a nice description of your changes when you submit your PR;
 if we have to read the whole diff to figure out why you're contributing
 in the first place, you're less likely to get feedback and have your change
-merged in.
+merged in. Also, split your changes into comprehensive chunks if you patch is
+longer than a dozen lines.
 If you are starting to work on a particular area, feel free to submit a PR
 that highlights your work in progress (and note in the PR title that it's
 ```
### `Коммит изменений`
Теперь, когда ваш индекс находится в таком состоянии, как вам и хотелось, вы можете
зафиксировать свои изменения. Запомните, всё, что до сих пор не проиндексировано —
любые файлы, созданные или изменённые вами, и для которых вы не выполнили `git add`
после момента редактирования — не войдут в этот коммит. Они останутся изменёнными
файлами на вашем диске. В нашем случае, когда вы в последний раз выполняли `git status`,
вы видели что всё проиндексировано, и вот, вы готовы к коммиту. Простейший способ
зафиксировать изменения — это набрать `git commit`:
```
git commit
```
Эта команда откроет выбранный вами текстовый редактор. (Редактор устанавливается
системной переменной `$EDITOR` — обычно это `vim` или `emacs`, хотя вы можете установить
ваш любимый с помощью команды `git config --global core.editor`).
В редакторе будет отображён следующий текст (это пример окна `Vim’а`):
```
# Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
# On branch master
# Changes to be committed:
# new file: README
# modified: CONTRIBUTING.md
#
~
~
~
".git/COMMIT_EDITMSG" 9L, 283C
```
Вы можете видеть, что комментарий по умолчанию для коммита содержит
закомментированный результат работы (`"выхлоп"`) команды `git status` и ещё одну пустую
строку сверху. Вы можете удалить эти комментарии и набрать своё сообщение или же
оставить их для напоминания о том, что вы фиксируете. (Для ещё более подробного
напоминания, что же именно вы поменяли, можете передать аргумент `-v` в команду `git
commit`. Это приведёт к тому, что в комментарий будет также помещена `дельта/diff`
изменений, таким образом вы сможете точно увидеть все изменения которые вы
совершили.) Когда вы выходите из редактора, **Git** создаёт для вас коммит с этим сообщением
(удаляя комментарии и вывод `diff’а`).
Есть и другой способ — вы можете набрать свой комментарий к коммиту в командной
строке вместе с командой `commit` указав его после параметра `-m`, как в следующем примере:
```
git commit -m "Story 182: Fix benchmarks for speed"
[master 463dc4f] Story 182: Fix benchmarks for speed
 2 files changed, 2 insertions(+)
 create mode 100644 README
```
Итак, вы создали свой первый коммит! Вы можете видеть, что коммит вывел вам немного
информации о себе: на какую ветку вы выполнили коммит (`master`), какая контрольная
сумма `SHA-1` у этого коммита (`463dc4f`), сколько файлов было изменено, а также статистику
по добавленным/удалённым строкам в этом коммите.
Запомните, что коммит сохраняет снимок состояния вашего индекса. Всё, что вы не
проиндексировали, так и висит в рабочем каталоге как изменённое; вы можете сделать ещё
один коммит, чтобы добавить эти изменения в репозиторий. Каждый раз, когда вы делаете
коммит, вы сохраняете снимок состояния вашего проекта, который позже вы можете
восстановить или с которым можно сравнить текущее состояние.
### `Игнорирование индексации`
Несмотря на то, что индекс может быть удивительно полезным для создания коммитов
именно такими, как вам и хотелось, он временами несколько сложнее, чем вам нужно в
процессе работы. Если у вас есть желание пропустить этап индексирования, **Git**
предоставляет простой способ. Добавление параметра `-a` в команду `git commit` заставляет **Git**
автоматически индексировать каждый уже отслеживаемый на момент коммита файл,
позволяя вам обойтись без `git add`:
```
git status
On branch master
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)
  modified: CONTRIBUTING.md
no changes added to commit (use "git add" and/or "git commit -a")
git commit -a -m 'added new benchmarks'
[master 83e38c7] added new benchmarks
 1 file changed, 5 insertions(+), 0 deletions(-)
 ```
 Обратите внимание на то, что в данном случае перед коммитом вам не нужно выполнять
`git add` для файла ``CONTRIBUTING.md``.

### `Удаление файлов`
Для того чтобы удалить файл из **Git**, вам необходимо удалить его из отслеживаемых файлов
(точнее, удалить его из вашего индекса) а затем выполнить коммит. Это позволяет сделать
команда `git rm`, которая также удаляет файл из вашего рабочего каталога, так что вы в
следующий раз не увидите его как `“неотслеживаемый”`.
Если вы просто удалите файл из своего рабочего каталога, он будет показан в секции
``Changes not staged for commit`` (измененные, но не проиндексированные) вывода
команды `git status`:
```
rm PROJECTS.md
git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes not staged for commit:
  (use "git add/rm <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)
  deleted: PROJECTS.md
no changes added to commit (use "git add" and/or "git commit -a")
```
Затем, если вы выполните команду `git rm`, удаление файла попадёт в индекс:
```
git rm PROJECTS.md
rm 'PROJECTS.md'
git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)
  deleted: PROJECTS.md
```
После следующего коммита файл исчезнет и больше не будет отслеживаться. Если вы
изменили файл и уже проиндексировали его, вы должны использовать принудительное
удаление с помощью параметра `-f`. Это сделано для повышения безопасности, чтобы
предотвратить ошибочное удаление данных, которые ещё не были записаны в снимок
состояния и которые нельзя восстановить из **Git**.
Другая полезная штука, которую вы можете захотеть сделать — это удалить файл из
индекса, оставив его при этом в рабочем каталоге. Другими словами, вы можете захотеть
оставить файл на жёстком диске, и убрать его из-под бдительного ока **Git**. Это особенно
полезно, если вы забыли добавить что-то в файл `.gitignore` и по ошибке проиндексировали,
например, большой файл с логами, или кучу промежуточных файлов компиляции. Чтобы
сделать это, используйте опцию `--cached`:
```
git rm --cached README
```
В команду `git rm` можно передавать файлы, каталоги или `glob-шаблоны`. Это означает, что
вы можете вытворять что-то вроде:
```
git rm log/\*.log
```
Обратите внимание на обратный слэш `(\)` перед `*`. Он необходим из-за того, что **Git**
использует свой собственный обработчик имён файлов вдобавок к обработчику вашего
командного интерпретатора. Эта команда удаляет все файлы имеющие расширение `.log`
находящиеся в директории `log/.` Или же вы можете сделать вот так:
```
 git rm \*~
 ```
 Эта команда удаляет все файлы, чьи имена заканчиваются на `~`.
### `Просмотр истории коммитов`
После того, как вы создали несколько коммитов или же склонировали репозиторий с уже
существующей историей коммитов, вероятно вам понадобится возможность посмотреть
что было сделано – историю коммитов. Одним из основных и наиболее мощных
инструментов для этого является команда `git log`.
Следующие несколько примеров используют очень простой проект `“simplegit”`. Чтобы
склонировать проект, используйте команду:
```
git clone https://github.com/schacon/simplegit-progit
```
Если вы запустите команду `git log` в папке склонированного проекта, вы увидите
следующий вывод:
```
git log
commit ca82a6dff817ec66f44342007202690a93763949
Author: Scott Chacon <schacon@gee-mail.com>
Date: Mon Mar 17 21:52:11 2008 -0700
  changed the version number
commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
Author: Scott Chacon <schacon@gee-mail.com>
Date: Sat Mar 15 16:40:33 2008 -0700
  removed unnecessary test
commit a11bef06a3f659402fe7563abf99ad00de2209e6
Author: Scott Chacon <schacon@gee-mail.com>
Date: Sat Mar 15 10:31:28 2008 -0700
  first commit
```
По умолчанию (без аргументов) `git log` перечисляет коммиты, сделанные в репозитории в
обратном к хронологическому порядке – последние коммиты находятся вверху. Из примера
можно увидеть, что данная команда перечисляет коммиты с их `SHA-1` контрольными
суммами, именем и электронной почтой автора, датой создания и сообщением коммита.
Команда `git log` имеет очень большое количество опций для поиска коммитов по разным
критериям. Рассмотрим наиболее популярные из них.
Одним из самых полезных аргументов является `-p`, который показывает разницу,
внесенную в каждый коммит. Так же вы можете использовать аргумент `-2`, который
позволяет установить лимит на вывод количества коммитов. В данном случае их будет
только два:
```
git log -p -2
commit ca82a6dff817ec66f44342007202690a93763949
Author: Scott Chacon <schacon@gee-mail.com>
Date: Mon Mar 17 21:52:11 2008 -0700
  changed the version number
diff --git a/Rakefile b/Rakefile
index a874b73..8f94139 100644
--- a/Rakefile
+++ b/Rakefile
@@ -5,7 +5,7 @@ require 'rake/gempackagetask'
 spec = Gem::Specification.new do |s|
  s.platform = Gem::Platform::RUBY
  s.name = "simplegit"
- s.version = "0.1.0"
+ s.version = "0.1.1"
  s.author = "Scott Chacon"
  s.email = "schacon@gee-mail.com"
  s.summary = "A simple gem for using Git in Ruby code."
commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
Author: Scott Chacon <schacon@gee-mail.com>
Date: Sat Mar 15 16:40:33 2008 -0700
  removed unnecessary test
diff --git a/lib/simplegit.rb b/lib/simplegit.rb
index a0a60ae..47c6340 100644
--- a/lib/simplegit.rb
+++ b/lib/simplegit.rb
@@ -18,8 +18,3 @@ class SimpleGit
  end
 end
-
-if $0 == __FILE__
- git = SimpleGit.new
- puts git.show
-end
\ No newline at end of file
``
Эта опция отображает аналогичную информацию но содержит разницу для каждой записи.
Очень удобно использовать данную опцию для код ревью или для быстрого просмотра
серии изменений. Так же есть возможность использовать серию опций для обобщения.
Например, если вы хотите увидеть сокращенную статистику для каждого коммита, вы
можете использовать опцию `--stat` :
``` 
git log --stat
```

commit ca82a6dff817ec66f44342007202690a93763949
Author: Scott Chacon <schacon@gee-mail.com>
Date: Mon Mar 17 21:52:11 2008 -0700
  changed the version number
 Rakefile | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
Author: Scott Chacon <schacon@gee-mail.com>
Date: Sat Mar 15 16:40:33 2008 -0700
  removed unnecessary test
 lib/simplegit.rb | 5 -----
 1 file changed, 5 deletions(-)
commit a11bef06a3f659402fe7563abf99ad00de2209e6
Author: Scott Chacon <schacon@gee-mail.com>
Date: Sat Mar 15 10:31:28 2008 -0700
  first commit
 README | 6 ++++++
 Rakefile | 23 +++++++++++++++++++++++
 lib/simplegit.rb | 25 +++++++++++++++++++++++++
 3 files changed, 54 insertions(+)
```
Как вы видите, опция `--stat` печатает под каждым из коммитов список и количество
измененных файлов, а также сколько строк в каждом из файлов было добавлено и удалено.
В конце можно увидеть суммарную таблицу изменений.
Следующей действительно полезной опцией является `--pretty`. Эта опция меняет формат
вывода. Существует несколько встроенных вариантов отображения. Например, опция
`oneline` печатает каждый коммит в одну строку, что может быть очень удобным если вы
просматриваете большое количество коммитов. К тому же, опции `short, full и fuller` делают
вывод приблизительно в том же формате, но с меньшим или большим количеством
информации соответственно:
```
git log --pretty=oneline
ca82a6dff817ec66f44342007202690a93763949 changed the version number
085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7 removed unnecessary test
a11bef06a3f659402fe7563abf99ad00de2209e6 first commit
```
Наиболее интересной опцией является `format`. Она позволяет создать свой формат для
вывода информации. Особенно это может быть полезным когда вы хотите сгенерировать вывод для автоматического анализа – так как вы указываете формат явно, он не будет
изменен даже после обновления **Git**:
```
git log --pretty=format:"%h - %an, %ar : %s"
ca82a6d - Scott Chacon, 6 years ago : changed the version number
085bb3b - Scott Chacon, 6 years ago : removed unnecessary test
a11bef0 - Scott Chacon, 6 years ago : first commit
```
### `Операции отмены`
В любой момент вам может потребоваться что-либо отменить. Здесь мы рассмотрим
несколько основных способов отмены сделанных изменений. Будьте осторожны, не все
операции отмены в свою очередь можно отменить! Это одна из редких областей **Git’а**, где
неверными действиями можно необратимо удалить результаты своей работы.
Отмена может потребоваться, если вы сделали коммит слишком рано, например, забыв
добавить какие-то файлы или комментарий к коммиту. Если вы хотите переделать коммит,
можно запустить `commit` с параметром `--amend` (дополнить):
```
git commit --amend
```
Эта команда использует для дополнения коммита вашу область подготовки (индекс). Если
вы ничего не меняли с момента последнего коммита (например, команда запущена сразу
после предыдущего коммита), то снимок состояния останется в точности таким же, а
изменится лишь комментарий к коммиту.
Запустится тот же редактор комментария к коммиту, но уже с комментарием к
предыдущему коммиту. Комментарий можно отредактировать точно так же, как обычно,
просто он заменит собой предыдущий Например, если вы фиксируете изменения, и понимаете, что забыли проиндексировать
изменения в файле, который хотели включить в коммит, можно сделать примерно так:
```
git commit -m 'initial commit'
git add forgotten_file
git commit --amend
```

В итоге получится единый коммит — второй коммит заменит результаты первого.

### ``Отмена подготовки файла``
В следующих двух разделах показано, как разбираться с изменениями вашей области
подготовки `(staging area)` и рабочего каталога. Радует, что команда, которой вы определяете
состояние этих областей, также напоминает вам, как отменять их изменения. Например,
скажем, вы изменили два файла, и хотите закоммитить их двумя раздельными
изменениями, но случайно набрали `git add *`, и добавили оба в индекс. Как отменить
добавление одного из них? Команда `git status` напомнит вам:
```
git add .
git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)
  renamed: README.md -> README
  modified: CONTRIBUTING.md  
```

Прямо под текстом `“Changes to be committed”` говорится: `git reset HEAD <file>...` для отмены
добавления в индекс. Давайте последуем этому совету, и отменим индексирование файла
`CONTRIBUTING.md`:
```
git reset HEAD CONTRIBUTING.md
Unstaged changes after reset:
M CONTRIBUTING.md
git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)
  renamed: README.md -> README
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)
  modified: CONTRIBUTING.md
```
# 6. Работа с удалёнными репозиториями
Для того, чтобы внести вклад в какой-либо `**Git**-проект`, вам необходимо уметь работать с
удалёнными репозиториями. Удалённые репозитории представляют собой версии вашего
проекта, сохранённые в интернете или ещё где-то в сети. У вас может быть несколько
удалённых репозиториев, каждый из которых может быть доступен для чтения или для
чтения-записи. Взаимодействие с другими пользователями предполагает управление
удалёнными репозиториями, а также отправку и получение данных из них. Управление
репозиториями включает в себя как умение добавлять новые, так и умение удалять
устаревшие репозитории, а также умение управлять различными удалёнными ветками,
объявлять их отслеживаемыми или нет и так далее. В данном разделе мы рассмотрим
некоторые из этих навыков.
## `Просмотр удалённых репозиториев`
Для того, чтобы просмотреть список настроенных удалённых репозиториев, вы можете
запустить команду `git remote`. Она выведет названия доступных удалённых репозиториев.
Если вы клонировали репозиторий, то увидите как минимум ``origin`` — имя по
умолчанию для исходного репозитория:
```
умолчанию для исходного репозитория:
git clone https://github.com/schacon/ticgit
Cloning into 'ticgit'...
remote: Reusing existing pack: 1857, done.
remote: Total 1857 (delta 0), reused 0 (delta 0)
Receiving objects: 100% (1857/1857), 374.35 KiB | 268.00 KiB/s, done.
Resolving deltas: 100% (772/772), done.
Checking connectivity... done.
$ cd ticgit
$ git remote
origin
```
Вы можете также указать ключ `-v`, чтобы просмотреть адреса для чтения и записи,
привязанные к репозиторию:
```
git remote -v
origin https://github.com/schacon/ticgit (fetch)
origin https://github.com/schacon/ticgit (push)
```
Если у вас больше одного удалённого репозитория, команда выведет их все. Например, для
репозитория с несколькими настроенными удалёнными репозиториями в случае
совместной работы нескольких пользователей, вывод команды может выглядеть примерно так:
```
cd grit
git remote -v
bakkdoor https://github.com/bakkdoor/grit (fetch)
bakkdoor https://github.com/bakkdoor/grit (push)
cho45 https://github.com/cho45/grit (fetch)
cho45 https://github.com/cho45/grit (push)
defunkt https://github.com/defunkt/grit (fetch)
defunkt https://github.com/defunkt/grit (push)
koke git://github.com/koke/grit.git (fetch)
koke git://github.com/koke/grit.git (push)
origin git@github.com:mojombo/grit.git (fetch)
origin git@github.com:mojombo/grit.git (push)
```
Это означает, что мы можем легко получить изменения от любого из этих пользователей.
Возможно, что некоторые из репозиториев доступны для записи, и в них можно отправлять
свои изменения, хотя вывод команды не даёт никакой информации о правах доступа.
### `Добавление удалённых репозиториев`
В предыдущих разделах мы уже упоминали и приводили примеры добавления удалённых
репозиториев, сейчас рассмотрим эту операцию подробнее. Для того, чтобы добавить
удалённый репозиторий и присвоить ему имя `(shortname)`, просто выполните команду `git
remote add` [shortname] [url]:
```
git remote
origin
git remote add pb https://github.com/paulboone/ticgit
git remote -v
origin https://github.com/schacon/ticgit (fetch)
origin https://github.com/schacon/ticgit (push)
pb https://github.com/paulboone/ticgit (fetch)
pb https://github.com/paulboone/ticgit (push)
```
Теперь вместо указания полного пути вы можете использовать `pb`. Например, если вы
хотите получить изменения, которые есть у Пола, но нету у вас, вы можете выполнить
команду `git fetch pb`:
```
git fetch pb
remote: Counting objects: 43, done.
remote: Compressing objects: 100% (36/36), done.
remote: Total 43 (delta 10), reused 31 (delta 5)
Unpacking objects: 100% (43/43), done.
From https://github.com/paulboone/ticgit
* [new branch] master -> pb/master
* [new branch] ticgit -> pb/ticgit 
```   

Ветка `master` из репозитория Пола сейчас доступна вам под именем `pb/master`. Вы можете
слить её с одной из ваших веток или переключить на неё локальную ветку, чтобы
просмотреть содержимое ветки Пола. 
# 7. Псевдонимы в Git
Git не будет пытаться сделать вывод о том, какую команду вы хотели ввести, если вы ввели
её неполностью. Если вы не хотите печатать каждую команду для **Git’а** целиком, вы легко
можете настроить псевдонимы (`alias`) для любой команды с помощью `git config`. Вот
несколько примеров псевдонимов, которые вы, возможно, захотите задать:

```
 git config --global alias.co checkout
$ git config --global alias.br branch
$ git config --global alias.ci commit
$ git config --global alias.st status
```
Это означает, что, например, вместо ввода `git commit`, вам достаточно набрать только `git ci`.
По мере освоения **Git’а** вам, вероятно, придётся часто пользоваться и другими командами. В
этом случае без колебаний создавайте новые псевдонимы.
Такой способ может также быть полезен для создания команд, которые, как вы думаете,
должны существовать. Например, чтобы исправить неудобство, с которым мы столкнулись
при исключении файла из индекса, можно добавить в **Git** свой собственный псевдоним
`unstage`:
```
git config --global alias.unstage 'reset HEAD --'
```
Это делает эквивалентными следующие две команды:
```
git unstage fileA
git reset HEAD -- fileA
```
Такой вариант кажется немного более понятным. Также, обычно, добавляют команду `last`
следующим образом:
```
 git config --global alias.last 'log -1 HEAD'
```
Таким образом, можно легко просмотреть последний коммит:
```
git last
commit 66938dae3329c7aebe598c2246a8e6af90d04646
Author: Josh Goebel <dreamer3@example.com>
Date: Tue Aug 26 19:48:51 2008 +0800
  test for current head
  Signed-off-by: Scott Chacon <schacon@example.com>
  
```
Можно сказать, что **Git** просто заменяет эти команды на созданные вами псевдонимы (`alias`).
Однако, возможно, вы захотите выполнить внешнюю команду, а не подкоманду **Git’а**`. В этом
случае, следует начать команду с символа `!`. Это полезно, если вы пишете свои утилиты для
работы с `Git-репозиторием`. Продемонстрируем этот случай на примере создания
псевдонима `git visual` для запуска `gitk`:
```
 git config --global alias.visual "!gitk"
```
## Заключение
Теперь вы умеете выполнять все базовые локальные операции с **Git’ом**: создавать или
клонировать репозиторий, вносить изменения, индексировать и фиксировать эти
изменения, а также просматривать историю всех изменений в репозитории. Дальше мы
рассмотрим `киллер-фичу` **Git’а** — его модель ветвления.

# 7. Ветвление в Git
Почти каждая система контроля версий (`СКВ`) в какой-то форме поддерживает ветвление.
Используя ветвление, Вы отклоняетесь от основной линии разработки и продолжаете
работу независимо от нее, не вмешиваясь в основную линию. Во многих `СКВ` создание веток
— это очень затратный процесс, часто требующий создания новой копии директории, что
может занять много времени для большого проекта.
Некоторые люди, говоря о модели ветвления **Git**, называют ее `“киллер-фича”`, что выгодно
выделяет **Git** на фоне остальных `СКВ`. Что в ней такого особенного? Ветвление **Git** очень
легковесно. Операция создания ветки выполняется почти мгновенно, переключение между
ветками туда-сюда, обычно, также быстро. В отличии от многих других `СКВ`, **Git** поощряет
процесс работы, при котором ветвление и слияние выполняется часто, даже по несколько
раз в день. Понимание и владение этой функциональностью дает Вам уникальный и
мощный инструмент, который может полностью изменить привычный Вам процесс
разработки. 
### Создание новой ветки
## О ветвлении в двух словах
Для четкого понимания механизма ветвлений, необходимо вернуться назад и изучить то,
как **Git** хранит данные.
Как вы можете помнить из `Введение`, **Git** не хранит данные в виде последовательности
изменений, он использует набор снимков (`snapshot`).
Когда вы делаете коммит, **Git** сохраняет его в виде объекта, который содержит указатель на
снимок (`snapshot`) подготовленных данных. Этот объект так же содержит имя автора и
`email`, сообщение и указатель на коммит или коммиты непосредственно предшествующие
данному (`его родителей`): отсутствие родителя для первоначального коммита, один
родитель для обычного коммита, и несколько родителей для результатов слияния веток.
Представьте себе каталог, который содержит дерево файлов, и вы подготавливаете их все
вместе, а затем сохраняете в виде одного коммита. В процессе подготовки вычисляется
контрольная сумма каждого файла (`SHA-1 как мы узнали из Введение`), хранящая версию
файла в репозитории **Git** (`**Git** ссылается на них`), затем эти контрольные суммы добавляются
в область подготовленных файлов:
```
git add README test.rb LICENSE
git commit -m 'initial commit of my project'
```
Когда вы создаете коммит командой `git commit`, **Git** вычисляет контрольные суммы каждого
подкаталога (в нашем случае, только основной каталог проекта) и сохраняет эти объекты
дерева в репозитории. Затем **Git** создает объект коммита с метаданными и указателем на
основное дерево проекта для возможности воссоздать этот снимок (`snapshot`) в случае
необходимости.
Ваш репозиторий **Git** теперь хранит пять объектов: `блоб` (`blob`) для содержимого каждого
файла, содержимое каталога в виде дерева с указателями на `блобы` сохраненных фалов, сам
коммит с указателем на основное дерево, метаданные коммита.
Если вы сделаете изменения и еще один коммит, тогда следующий коммит сохранит
указатель на коммит, предшествующий ему.
Ветка (`branch`) в **Git** — это легко перемещаемый указатель на один из этих коммитов. Имя
основной ветки по умолчанию в `**Git** — master`.
Когда вы делаете коммиты, то получаете основную ветку, указывающую на ваш последний
коммит. Каждый коммит автоматически двигает этот указатель вперед.
Ветка `“master”` в **Git** — это не специальная ветка. Она точно такая же, как и
все остальные ветки. Она существует почти во всех репозиториях только
лишь потому, что ее создает команда `git init`, а большинство людей не
меняют ее название.
## Создание новой ветки
Что же на самом деле происходит, когда вы создаете ветку? Всего лишь создается новый
указатель для дальнейшего перемещения. Допустим вы хотите создать новую ветку с
именем `“testing”` Вы можете это сделать командой `git branch` :
```
 git branch testing
```
В результате создается новый указатель на тот же самый коммит, в котором вы находитесь.
Как **Git** определяет, в какой ветке вы находитесь? Он хранит специальный указатель `HEAD`.
Имейте ввиду, что в **Git** концепция `HEAD` значительно отличается от других систем контроля
версий, которые вы могли использовать раньше (Subversion или CVS). В **Git** это указатель на локальную ветку, в которой вы находитесь. В нашем случае мы все еще находимся в ветке
`“master”`. Команда `git branch` только создает новую ветку. Переключения не происходит.
версий, которые вы могли использовать раньше (`Subversion или CVS`). В **Git** это указатель на
локальную ветку, в которой вы находитесь. В нашем случае мы все еще находимся в ветке
“`master`”. Команда `git branch` только создает новую ветку. Переключения не происходит.
Вы можете легко это увидеть при помощи простой команды `git log`. Она покажет вам, куда
указывают указатели веток. Эта опция называется `--decorate`.
```
git log --oneline --decorate
f30ab (HEAD, master, testing) add feature #32 - ability to add new
34ac2 fixed bug #1328 - stack overflow under certain conditions
98ca9 initial commit of my project
```
Видны ветки `“master”` и `“testing”`, которые указывают на коммит `f30ab`.
### Переключение веток
Чтобы переключиться на существующую ветку, выполните команду `git checkout`. Давайте
переключимся на ветку `“testing”`:
```
 git checkout testing
```
Видны ветки “`master`” и “`testing`”, которые указывают на коммит `f30ab`.
## Переключение веток
Чтобы переключиться на существующую ветку, выполните команду `git checkout`. Давайте
переключимся на ветку “`testing`”:
```
git checkout testing
```
В результате указатель `HEAD` переместится на ветку `testing`.
Какой в этом смысл? Давайте сделаем еще один коммит:
```
vim test.rb
git commit -a -m 'made a change'
```
Это интересно, потому что указатель на вашу ветку `“testing”` переместился вперед, а
`“master”` все еще указывает на тот коммит, где вы были в момент выполнения команды `git checkout` для переключения веток. Давайте переключимся назад на ветку `“master”`:
```
git checkout master
```
Эта команда сделала две вещи. Она переместила указатель `HEAD` назад на ветку `“master”` и
вернула файлы в рабочем каталоге в то состояние, которое было сохранено в снимке
`(snapshot)`, на который указывает ветка. Это также означает, что все изменения, вносимые с
этого момента, будут отнесены к старой версии проекта. Другими словами, откатилась вся
работа, выполненная в ветке `“testing”`, а вы можете продолжать в другом направлении.
Переключение веток меняет файлы в рабочем каталоге
Это интересно, потому что указатель на вашу ветку “`testing`” переместился вперед, а
“`master`” все еще указывает на тот коммит, где вы были в момент выполнения команды `git checkout` для переключения веток. Давайте переключимся назад на ветку “`master`”:
```
git checkout master
```
Эта команда сделала две вещи. Она переместила указатель `HEAD` назад на ветку “`master`” и
вернула файлы в рабочем каталоге в то состояние, которое было сохранено в снимке
(`snapshot`), на который указывает ветка. Это также означает, что все изменения, вносимые с
этого момента, будут отнесены к старой версии проекта. Другими словами, откатилась вся
работа, выполненная в ветке “`testing`”, а вы можете продолжать в другом направлении.
Важно запомнить, что когда вы переключаете ветки в **Git**, файлы в рабочем
каталоге меняются. Если вы переключаетесь на старую ветку, то рабочий
каталог будет выглядеть так же, как выглядел на момент последнего коммита
в ту ветку. Если **Git** по каким-то причинам не может этого сделать — он не
позволит вам переключиться.
Давайте сделаем еще несколько изменений и очередной коммит:
```
vim test.rb
git commit -a -m 'made other changes'
```
Теперь история вашего проекта разделилась (см `Разветвленная история`). Вы создали ветку,
переключились в нее, поработали, а затем вернулись в основную ветку и поработали в ней.
Эти изменения изолированы друг от друга: вы можете свободно переключаться туда и
обратно, а когда будете готовы — слить их вместе. И все это делается простыми командами:
`branch, checkout `и `commit`.
Все это вы можете увидеть при помощи команды `git log`. Команда `git log --oneline --decorate --graph --all`выдаст историю ваших коммитов и покажет, где находятся
указатели ваших веток, и как ветвилась история проекта.
```
git log --oneline --decorate --graph --all
* c2b9e (HEAD, master) made other changes
| * 87ab2 (testing) made a change
|/
* f30ab add feature #32 - ability to add new formats to the
* 34ac2 fixed bug #1328 - stack overflow under certain conditions
* 98ca9 initial commit of my project
```
Cоздание и удаление веток совершенно не затратно, так как ветка в **Git** — это всего лишь
файл, содержащий 40 символов контрольной суммы SHA-1 того коммита, на который он
файл, содержащий 40 символов контрольной суммы `SHA-1` того коммита, на который он
указывает. Создание новой ветки совершенно быстро и просто — это всего лишь запись 41
байта в файл (40 знаков и перевод строки).
Это совершенно отличает **Git** от ветвления в большинстве более старых систем контроля
версий, где все файлы проекта копируются в другой подкаталог. Там ветвление для
проектов разного размера может занять от секунд до минут. В **Git** ветвление всегда
мгновенное. Также, поскольку при коммите мы сохраняем указатель на родительский
коммит, найти подходящую базу для слияния в основном очень просто, и это делается для
нас автоматически. 
Давайте посмотрим, почему и вам имеет смысл делать так же.
# 8.Основы ветвления и слияния
Основы ветвления и слияния нас автоматически. Эти возможности побуждают разработчиков чаще создавать и использовать ветки.
Давайте посмотрим, почему и вам имеет смысл делать так же.
## Основы ветвления и слияния
Давайте рассмотрим простой пример рабочего процесса, который может быть полезен в
вашем проекте. Ваша работа построена так:
1. Вы работаете над сайтом.
2. Вы создаете ветку для новой статьи, которую вы пишете.
3. Вы работаете в этой ветке.
В этот момент вы получаете сообщение, что обнаружена критическая ошибка, требующая
скорейшего исправления. Ваши действия:
1. Переключиться на основную ветку.
2. Создать ветку для добавления исправления.
3. После тестирования слить ветку содержащую исправление с основной веткой.
4. Переключиться назад в ту ветку где вы пишите статью и продолжить работать.

### Основы слияния
Предположим, вы решили, что работа по проблеме `#53` закончена, и ее можно влить в ветку
`master`. Для этого нужно выполнить слияние ветки `iss53` точно так же, как вы делали это с
веткой `hotfix` ранее. Все что нужно сделать — переключиться на ветку, в которую вы хотите
включить изменения, и выполнить команду `git merge`:
```
git checkout master
Switched to branch 'master'
git merge iss53
Merge made by the 'recursive' strategy.
index.html | 1 +
1 file changed, 1 insertion(+)
```
Результат этой операции отличается от результата слияния ветки `hotfix`. В данном случае
процесс разработки ответвился в более ранней точке. Так как коммит, на котором мы
находимся, не является прямым потомком ветки, с которой мы выполняем слияние, **Git**
придется немного потрудиться. В этом случае **Git** выполняет простое трехстороннее слияние
двух снимков (`snapshot`) сливаемых веток и общего для двух веток родительского снимка.
Вместо того, чтобы просто передвинуть указатель ветки вперед, **Git** создает новый снимок результат трехстороннего слияния, а затем автоматически делает коммит. Этот особый
коммит называют коммитом слияния, так как у него более одного предка.
Стоит отметить, что Git сам определяет наилучшего общего предка, подходящего как база
для слияния; это отличает его от более старых инструментов, таких как CVS или Subversion
(до версии 1.5), где разработчикам, выполнявшим слияние, приходилось самим находить
лучшую базу. Это безумно упрощает слияние в **Git** по сравнению с указанными системами.
Теперь, когда работа влита, ветка `iss53` больше не нужна. Вы можете закрыть вопрос в
системе отслеживания ошибок и удалить ветку:
```
 git branch -d iss53
```
### Основные конфликты слияния
Иногда процесс не проходит гладко. Если вы изменили одну и ту же часть одного и того же
файла по-разному в двух объединяемых ветках, **Git** не сможет их чисто объединить. Если
ваше исправление ошибки `#53` потребовало изменить ту же часть файла, что и `hotfix`, вы
получите примерно такое сообщение о конфликте слияния:
```
git merge iss53
Auto-merging index.html
CONFLICT (content): Merge conflict in index.html
Automatic merge failed; fix conflicts and then commit the result.
```
**Git** не создал коммит слияния автоматически. Он остановил процесс до тех пор, пока вы не
разрешите конфликт. Чтобы в любой момент после появления конфликта увидеть, какие
файлы не объединены, вы можете запустить `git status`:
```
git status
On branch master
You have unmerged paths.
  (fix conflicts and run "git commit")
Unmerged paths:
  (use "git add <file>..." to mark resolution)
  both modified: index.html
no changes added to commit (use "git add" and/or "git commit -a")
```
Все, где есть неразрешенные конфликты слияния, перечисляется как неслитое. **Git**
добавляет в конфликтующие файлы стандартные пометки разрешения конфликтов, чтобы
вы могли вручную открыть их и разрешить конфликты. В вашем файле появился раздел,
выглядящий примерно так:
```
<<<<<<< HEAD:index.html
<div id="footer">contact : email.support@github.com</div>
=======
<div id="footer">
 please contact us at support@github.com
</div>
>>>>>>> iss53:index.html
```
Это означает, что версия из `HEAD` (вашей ветки `master`, поскольку именно ее вы выгрузили,
запустив команду слияния) — это верхняя часть блока (все, что над `=======`), а версия из
вашей ветки `iss53` представлена в нижней части. Чтобы разрешить конфликт, придется
выбрать одну из сторон, либо объединить содержимое по-своему. Например, вы можете
разрешить конфликт, заменив весь блок этим:
```
<div id="footer">
please contact us at email.support@github.com
</div>
```
В этом разрешении есть немного от каждой части, а строки `<<<<<<<, ======= и >>>>>>>` совсем убраны. Разрешив каждый конфликт во всех файлах, запустите `git add` для каждого файла,
чтобы отметить конфликт как решенный. Подготовка (`staging`) файла помечает его для **Git**как разрешенный конфликт.
Если вы хотите использовать графический инструмент для разрешения конфликтов, можно запустить `git mergetool`, что откроет соответствующее визуальное средство, которое
проведет вас по всем конфликтам:
```
git mergetool
This message is displayed because 'merge.tool' is not configured.
See 'git mergetool --tool-help' or 'git help config' for more details.
'git mergetool' will now attempt to use one of the following tools:
opendiff kdiff3 tkdiff xxdiff meld tortoisemerge gvimdiff diffuse diffmerge ecmerge
p4merge araxis bc3 codecompare vimdiff emerge
Merging:
index.html
Normal merge conflict for 'index.html':
  {local}: modified file
  {remote}: modified file
Hit return to start merge resolution tool (opendiff):
```
Если вы хотите использовать средство слияния не по умолчанию (в данном случае **Git** выбрал `opendiff`, поскольку команда запускалась на Mac), список всех поддерживаемых
инструментов представлен вверху после фразы “`one of the following tools.`” Просто введите название инструмента, который нужно использовать.
После выхода из средства слияния **Git** спрашивает, успешно ли слияние. Если вы утвердительно ответите скрипту, он подготовит (`stage`) файл, чтобы отметить его как разрешенный. Теперь можно снова запустить `git status`, чтобы убедиться, что все
конфликты разрешены:
```
git status
On branch master
All conflicts fixed but you are still merging.
  (use "git commit" to conclude merge)
Changes to be committed:
  modified: index.html
```
Если это вас устраивает, и вы убедились, что все, где были конфликты, подготовлено (`staged`), можете ввести `git commit`, чтобы завершить коммит слияния. Комментарий к
коммиту по умолчанию выглядит примерно так:
```
Merge branch 'iss53'
Conflicts:
  index.html
#
# It looks like you may be committing a merge.
# If this is not correct, please remove the file
# .git/MERGE_HEAD
# and try again.
# Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
# On branch master
# All conflicts fixed but you are still merging.
#
# Changes to be committed:
# modified: index.html
#
```
Вы можете дополнить это сообщение подробностями того, как были разрешены конфликты,если считаете, что это поможет другим в будущем разобраться в данном слиянии, если это не очевидно: что вы сделали и почему.

### Управление ветками
Теперь, когда вы уже попробовали создавать, объединять и удалять ветки, пора познакомиться с некоторыми инструментами для управления ветками, которые вам пригодятся, когда вы начнёте использовать ветки постоянно.
Команда `git branch` делает несколько больше, чем просто создаёт и удаляет ветки. При запуске без параметров, вы получите простой список имеющихся у вас веток:
```
git branch
  iss53
* master
  testing
```
Обратите внимание на символ `*`, стоящий перед веткой `master`: он указывает на ветку, на которой вы находитесь в настоящий момент (т.е. ветку, на которую указывает `HEAD`). Это означает, что если вы сейчас выполните коммит, ветка `master` переместится вперёд в
соответствии с вашими последними изменениями. Чтобы посмотреть последний коммит на каждой из веток, выполните команду `git branch -v`:
```
git branch -v
  iss53 93b412c fix javascript issue
* master 7a98805 Merge branch 'iss53'
  testing 782fd34 add scott to the author list in the readmes
```
Ещё одна полезная возможность для выяснения состояния веток состоит в том, чтобы оставить в этом списке только те ветки, которые вы слили (или не слили) в ветку, на которой сейчас находитесь. Для этих целей в **Git’е** есть опции `--merged` и `--no-merged`. Чтобы посмотреть те ветки, которые вы уже слили с текущей, можете выполнить команду `
```
git branch --merged
git branch --no-merged
  iss53
* master
```
Из-за того, что вы ранее слили `iss53`, она присутствует в этом списке. Те ветки из этого списка, перед которыми нет символа `*`, можно смело удалять командой `git branch -d`; наработки из этих веток уже включены в другую ветку, так что ничего не потеряется.
Чтобы увидеть все ветки, содержащие наработки, которые вы пока ещё не слили в текущую ветку, выполните команду `git branch --no-merged`:
```
git branch --no-merged
  testing
```
Вы увидите оставшуюся ветку. Так как она содержит ещё не слитые наработки, попытка удалить её командой `git branch -d` приведет к ошибке:
```
git branch -d testing
error: The branch 'testing' is not fully merged.
If you are sure you want to delete it, run 'git branch -D testing'.
```
Если вы действительно хотите удалить ветку и потерять наработки, вы можете сделать это при помощи опции `-D`, как указано в подсказке.
## Работа с ветками
Теперь, когда вы познакомились с основами ветвления и слияния. Возникает вопрос: что еще можно делать с ветками? В этом разделе мы разберем некоторые стандартные рабочие примеры, ставшие возможными благодаря облегченной процедуре ветвления. Возможно, что-то из этого вы сможете включить в собственный цикл разработки.
### Основы ветвления
Предположим, вы работаете над проектом и уже имеете несколько коммитов.
Вы решаете, что теперь вы будете заниматься проблемой `#53` из вашей системы отслеживания ошибок. Чтобы создать ветку и сразу переключиться на нее, можно выполнить команду `git checkout` с параметром `-b`:
```
git checkout -b iss53
Switched to a new branch "iss53"
```
Это тоже самое что и:
```
git branch iss53
git checkout iss53
```
Вы работаете над своим сайтом и делаете коммиты. Это приводит к тому, что ветка `iss53` движется вперед, так как вы переключились на нее ранее (`HEAD` указывает на нее).
```
vim index.html
git commit -a -m 'added a new footer [issue 53]'
```
Тут вы получаете сообщение об обнаружении уязвимости на вашем сайте, которую нужно немедленно устранить. Благодаря **Git**, не требуется размещать это исправление вместе с тем, что вы сделали в `iss53`. Вам даже не придется прилагать усилий, чтобы откатить все эти изменения для начала работы над исправлением. Все, что вам нужно — переключиться
на ветку `master`.
Но перед тем как сделать это — имейте в виду, что если ваш рабочий каталог либо область
подготовленных файлов содержат изменения, не попавшие в коммит и конфликтующие с веткой, на которую вы хотите переключиться, то **Git** не позволит вам переключить ветки.
Лучше всего переключаться из чистого рабочего состояния проекта. Есть способы обойти это (спрятать (`stash`) или исправить (`amend`) коммиты), но об этом мы поговорим позже в главе Прибережение и очистка. Теперь предположим, что вы зафиксировали все свои изменения и можете переключиться на основную ветку:
```
git checkout master
Switched to branch 'master'
```
С этого момента ваш рабочий каталог имеет точно такой же вид, какой был перед началом работы над проблемой `#53`. Теперь вы можете сосредоточиться на работе над исправлением.
Важно запомнить: когда вы переключаете ветки, **Git** возвращает состояние рабочего каталога к тому виду, какой он имел в момент последнего коммита в эту ветку. Он добавляет, удаляет и изменяет файлы автоматически, чтобы состояние рабочего каталога соответствовало тому, когда был сделан последний коммит.
Теперь вы можете перейти к написанию исправления. Давайте создадим новую ветку для исправления, в которой будем работать, пока не закончим исправление.
```
git checkout -b hotfix
Switched to a new branch 'hotfix'
$ vim index.html
git commit -a -m 'fixed the broken email address'
[hotfix 1fb7853] fixed the broken email address
 1 file changed, 2 insertions(+)
```
Вы можете прогнать тесты, чтобы убедиться, что ваше исправление делает именно то, что нужно. И если это так — выполнить слияние (`merge`) с основной веткой для включения в продукт. Это делается командой `git merge`:
```
git checkout master
git merge hotfix
Updating f42c576..3a0874c
Fast-forward
 index.html | 2 ++
 1 file changed, 2 insertions(+)
```
Заметили фразу “`fast-forward`” в этом слиянии? Из-за того, что коммит, на который указывала ветка, которую вы слили, был прямым потомком того коммита, на котором вы находились, **Git** просто переместил указатель ветки вперед. Другими словами, если коммит
сливается с тем, до которого можно добраться, двигаясь по истории прямо, **Git** упрощает слияние, просто перенося указатель метки вперед (так как нет разветвления в работе). Это называется `fast-forward` (перемотка). Теперь ваши изменения — в снимке (`snapshot`) коммита, на который указывает ветка `master`, и исправления продукта можно внедрять.
После внедрения вашего архиважного исправления вы готовы вернуться к работе над тем, что были вынуждены отложить. Но сначала нужно удалить ветку `hotfix`, потому что она больше не нужна — ветка `master` указывает на то же самое место. Для удаления ветки
выполните команду `git branch` с параметром `-d`:
```
git branch -d hotfix
Deleted branch hotfix (3a0874c).
```
Теперь вы можете переключить ветку и вернуться к работе над своей проблемой `#53`:
```
git checkout iss53
Switched to branch "iss53"
$ vim index.html
git commit -a -m 'finished the new footer [issue 53]'
[iss53 ad82d7a] finished the new footer [issue 53]
1 file changed, 1 insertion(+)
```
Стоит обратить внимание на то, что все изменения из ветки `hotfix` не включены в вашу
ветку `iss53`. Если их нужно включить, вы можете влить ветку `master` в вашу ветку `iss53`
командой `git merge master`, или же вы можете отложить слияние этих изменений до
завершения работы, и затем влить ветку `iss53` в `master`.

### Долгоживущие ветки
Так как в **Git** применяется простое трехэтапное слияние, ничто не мешает многократно объединять ветки в течении длительного времени. То есть у вас может быть несколько постоянно открытых веток, применяемых для разных этапов цикла разработки.
Содержимое некоторых из них будет регулярно сливаться в другие ветки.
Многие разработчики, использующие **Git**, придерживаются именно такого подхода, оставляя полностью стабильный код только в ветке `master`. При этом существует и параллельная ветка с именем `develop` или `next`, служащая для работы и тестирования стабильности. После достижения стабильного результата ее содержимое сливается в ветку
`master`. Она используется для объединения завершенных задач из тематических веток (временных веток наподобие iss53), чтобы гарантировать, что эти задачи проходят тестирование и не вносят ошибок.
По сути, мы рассматриваем указатели, перемещающиеся по линии фиксируемых нами изменений. Стабильные ветки находятся в нижнем конце истории коммитов, а самые свежие наработки — ближе к ее верхней части.
В общем случае можно представить набор рабочих накопителей, в котором наборы коммитов перемещаются на более стабильный уровень только после полного тестирования.
Число уровней стабильности можно увеличить. В крупных проектах зачастую появляется ветка `proposed` или `pu` `(proposed updates)`, объединяющая ветки с содержимым, которое невозможно включить в ветку `next` или `master`. Фактически каждая ветка представляет собственный уровень стабильности. Как только он повышается, содержимое сливается в
ветку, расположенную выше. Разумеется, можно и вообще обойтись без долгоживущих веток, но зачастую они имеют смысл, особенно при работе над большими и сложными проектами.
### Тематические ветки
А вот такая вещь, как тематические ветки, полезна вне зависимости от величины проекта.
Тематической `(topic branch)` называется временная ветка, создаваемая и используемая для работы над конкретной функциональной возможностью или решения сопутствующих задач. Скорее всего, при работе с другими `СКВ` вы никогда ничего подобного не делали, так как там создание и слияние веток — затратные операции. Но в **Git** принято много раз в день создавать ветки, работать с ними, сливать их и удалять.
Пример тематических веток вы видели в предыдущем разделе, когда мы создавали ветки `iss53` и `hotfix`. Для каждой из них было выполнено несколько коммитов, после чего сразу же после слияния с основной веткой они были удалены. Такая техника позволяет быстро и радикально осуществлять переключения контекста. Работа разделена по уровням, и все изменения в конкретной ветке относятся к определенной теме, а значит, во время просмотра кода проще понять, что и где было сделано. Ветку с внесенными в нее изменениями можно хранить минуты, дни или даже месяцы, и выполнять ее слияние, только когда это действительно требуется, независимо от порядка создания веток в рамках
проекта и порядка работы с ними.
Предположим, мы работаем в ветке `master`, ответвляемся для решения попутной проблемы (iss91), некоторое время занимаемся ею, затем создаем ветку, чтобы попробовать решить эту задачу другим способом (iss91v2), возвращаемся в ветку `master`, выполняем там некие действия и создаем новую ветку для действий, в результате которых не уверены (ветка dumbidea). 
### Удалённые ветки
Удалённые ветки — это ссылки `(pointers)` на состояние веток в ваших удалённых репозиториях. Это локальные ветки, которые нельзя перемещать; они двигаются автоматически всякий раз, когда вы осуществляете связь по сети. Удалённые ветки
действуют как закладки для напоминания о том, где ветки в удалённых репозиториях находились во время последнего подключения к ним.
Они выглядят как `(имя удал. репоз.)/(ветка)`. Например, если вы хотите посмотреть, как выглядела ветка `master` на сервере `origin` во время последнего соединения с ним, проверьте
ветку `origin/master`. Если вы с партнёром работали над одной проблемой, и он выложил ветку `iss53`, у вас может быть своя локальная ветка `iss53`; но та ветка на сервере будет
указывать на коммит в `origin/iss53`.
Всё это, возможно, сбивает с толку, поэтому давайте рассмотрим пример. Скажем, у вас в сети есть свой **Git**`-сервер` на `git.ourcompany.com.` Если вы с него что-то склонируете, **Git** команда `clone` автоматически назовёт его `origin`, заберёт оттуда все данные, создаст указатель на то, на что там указывает ветка `master`, и назовёт его локально `origin/master. **Git**`
также сделает вам вашу собственную локальную ветку `master`, которая будет начинаться там же, где и ветка `master` в `origin`, так что вам будет с чем работать.
`“origin”` — это не специальное название.
Подобно тому, как название ветки `“master”` не имеет какого-либо
специального значения в **Git**, также и название `“origin”`. В то время как
`“master”` — это название по умолчанию для исходной ветки, когда вы
запускаете `git init`, по единственной причине, что широко используется, `“origin”` — это название по умолчанию для удаленной ветки, когда вы запускаете `git clone`. Если вы запустите `git clone -o booyah`, так вы будете иметь `booyah/master` как вашу удаленную ветку по умолчанию.
Если вы сделаете что-то в своей локальной ветке `master`, а тем временем кто-то ещё отправит `(push)` изменения на `git.ourcompany.com` и обновит там ветку `master`, то ваши
истории продолжатся по-разному. Ещё, до тех пор, пока вы не свяжетесь с сервером `origin`, ваш указатель `origin/master` не будет сдвигаться.
Для синхронизации вашей работы выполняется команда `git fetch origin`. Эта команда ищет, какому серверу соответствует `“origin”` (в нашем случае это `git.ourcompany.com`); извлекает оттуда все данные, которых у вас ещё нет, и обновляет ваше локальное хранилище данных; сдвигает указатель `origin/master` на новую позицию.
```
 git fetch обновляет ваши удаленные ссылки
```

Чтобы продемонстрировать то, как будут выглядеть удалённые ветки в ситуации с несколькими удалёнными серверами, предположим, что у вас есть ещё один внутренний `**Git**-сервер`, который используется для разработки только одной из ваших команд разработчиков. Этот сервер находится на `git.team1.ourcompany.com.` Вы можете добавить его в
качестве новой удалённой ссылки на проект, над которым вы сейчас работаете с помощью команды `git remote add` так же, как было описано в Основы **Git**. Дайте этому удалённому серверу имя `teamone`, которое будет сокращением для полного URL.
Теперь можете выполнить `git fetch teamone`, чтобы извлечь всё, что есть на сервере и нет у вас. Так как в данный момент на этом сервере есть только часть данных, которые есть на
сервере `origin`, **Git** не получает никаких данных, но выставляет удалённую ветку с именем `teamone/master`, которая указывает на тот же коммит, что и ветка `master` на сервере `teamone`.

# 9.GitHub
Гитхаб это крупнейшее хранилище **Git** репозиториев, а так же центр сотрудничества для
миллионов разработчиков и проектов. Огромный процент репозиториев хранится на
`Гитхабе`. Многие проекты с открытым исходным кодом используют его ради **Git** хостинга,
баг-трекера, рецензирования кода и других вещей. Так что, пока всё это не часть открытого
`**Git** проекта`, наверняка вы захотите, или вам придётся взаимодействовать с `Гитхабом` при
профессиональном использовании **Git**.
Эта глава про эффективное использование `Гитхаба`. Мы разберём регистрацию, управление
учетной записью, создание и использование `**Git** репозиториев`, как вносить вклад в чужие
проекты и как принимать чужой вклад в собственный проект, а так же программный
интерфейс `Гитхаба` и ещё множество мелочей, который облегчат вам жизнь.
Если вас не интересует использование `Гитхаба` для размещения собственных проектов или
сотрудничества с другими проектами, размещёнными на нём, вы можете смело перейти к
Инструменты **Git**.
`Изменения в интерфейсе`
Важно отметить, что, как и на многих активных веб-сайтах, элементы
интерфейса со скриншотов обязательно со временем изменятся.
Надеемся, общее представление о том, что мы пытаемся сделать
останется, но, если вы хотите более актуальных скриншотов, возможно
вы найдёте их в онлайн версии этой книги.
### Настройка и конфигурация учетной записи
Первым делом нужно создать беcплатную учетную запись. Просто зайдите на
https://github.com или [сайт](https://github.com) , выберите имя которое ещё не занято, укажите адрес электронной почты и
пароль, а затем нажмите большую зеленую кнопку `“Sign up for GitHub”`.
Далее вы попадете на страницу с тарифными планами, её пока можно проигнорировать.
`Github` вышлет письмо для проверки вашего электронного адреса. Сделайте этот шаг, он
достаточно важный (как мы увидим далее).

`Github` предоставляет всю функциональность для бесплатных учетных
записей, за исключением того, что все ваши репозитории полностью
публичны (у любого есть доступ на чтение). Тарифные планы `Github’а`
включают определенное количество частных проектов, но мы не будем их
рассматривать в этой книге.
Кликнув по иконке октокота, вы попадете на страницу панели управления. Теперь Вы
готовы пользоваться `Github’ом`.
### Доступ по SSH
На данный момент вы можете подключаться к репозиториям **Git** используя протокол
`https://` авторизуясь при помощи только что созданного логина и пароля. Однако для того
чтобы просто клонировать публично доступный проект, вам необязательно
авторизироваться на сайте, но тем не менее, только что созданный аккаунт понадобится в
то время, когда вы захотите загрузить `(push)` сделанные вами изменения.
Если же вы хотите использовать `SSH` доступ, в таком случае вам понадобится добавить
публичный `SSH ключ`. (Если же у вас нет публичного SSH ключа, вы можете его
сгенерировать Генерация открытого SSH ключа) Откройте настройки вашей учетной при
помощи ссылки, расположенной в верхнем правом углу окна.
Выберите секцию слева под названием `“Ключи SSH”(“SSH keys”)`.
Затем нажмите на кнопку `"Добавить ключ SSH"("Add an SSH key")`, задайте имя ключа а так же
скопируйте и вставьте сам публичный ключ из `~/.ssh/id_rsa.pub` (ну или как бы у вас не
назывался этот файл) в текстовое поле, затем нажмите `“Добавить ключ”(“Add key”)`.
Задавайте такое имя `SSH ключа`, которое вы в состоянии запомнить.
Называйте каждый из добавляемых ключей по-разному (к примеру "Мой
Ноутбук" или "Рабочая учётная запись"), для того чтобы в дальнейшем, при
аннулировании ключа быть уверенным в правильности своего выбора.
### Ваш аватар
Следующий шаг, если хотите – замена аватара, который был сгенерирован для вас, на вами
выбранный аватар. Пожалуйста зайдите во вкладку `“Профиль”(“Profile”)`, она расположена
над вкладкой `"Ключи SSH" и нажмите “Загрузить новую картинку”(“Upload new picture”)`.
Выберем логотип **Git-а** с жёсткого диска и отредактируем картинку под желаемый размер.
После загрузки каждый сможет увидеть ваш аватар рядом с вашим именем пользователя.
Если вы используете такой популярный сервис как `Gravatar` (часто используется для
учетных записей Wordpress), тот же самый аватар будет использован "по умолчанию".
### Ваши почтовые адреса
`GitHub` использует ваш почтовый адрес для привязки ваших **Git** коммитов к вашей учётной
записи. Если вы используете несколько почтовых адресов в своих коммитах и хотите,
чтобы `GitHub` работал с ними корректно, то вам нужно будет добавить все используемые
`почтовые адреса` в секцию под названием `"Почтовые адреса" ("Emails")`, расположенную на
вкладке `"Администрирование" ("Admin")`.
Как можно видеть на рисунке `Почтовые адреса`, у почтовых адресов имеются несколько
состояний. Верхний почтовый адрес подтвержден и является основным для пользователя,
это тот самый адрес, куда будут направляться оповещения, а также остальные уведомления.
Второй адрес тоже подтвержден, и так же может быть назначен в качестве основного.
Последний адрес не подтвержден, это значит, что вы не можете использовать его в качестве
основного и получать на него уведомления. При отправке коммита в любой из
репозиториев, `GitHub` распознает один из указанных почтовых адресов и автоматически
привяжет этот коммит к вашей учетной записи.
### Двухфакторная аутентификация
В качестве дополнительной меры безопасности, вы можете настроить ``"Двухфакторную
аутентификацию"(“Two-factor Authentication” или “2FA”)``. Двухфакторная аутентификация —
механизм, который становится все более и более популярным методом по снижению риска
скомпрометировать вашу учетную запись в ситуации, когда пароль от вашей учетной
записи, по тем или иным причинам, стал известен злоумышленникам. Активация этого
механизма заставит `GitHub` запрашивать у вас оба пароля при авторизации, поэтому даже в
ситуациях, когда ваш основной пароль скомпрометирован, злоумышленник все равно не
получит доступ к вашей учетной записи.
Вы сможете найти настройку `"Двухфакторной аутентификации" (“Two-factor
Authentication”) в секции "Безопасность" ("Security") вкладки “Настройка учетной
записи”(“Account settings”)`.
При нажатии на кнопку “Настроить двухфакторную аутентификацию”(“Set up two-factor
authentication”) вы будете перенаправлены на страницу, где вам нужно будет настроить
использование мобильного приложения для генерации вторичного кода проверки (так
называемый “одноразовый пароль основанный на времени”), так же можно настроить
`GitHub` таким образом, чтобы он отправлял вам СМС с кодом в момент, когда вам нужно
авторизоваться на сайте.
После того, как вы выберете предпочитаемый вами метод и выполните предлагаемые
инструкции, ваша учетная запись будет в большей безопасности, и вам будет
предоставляться дополнительный код во время авторизации на сайте.
## Внесение собственного вклада в проекты
Теперь наша учетная запись создана и настроена, давайте же пройдемся по деталям,
которые будут полезны при внесении вклада в уже существующие проекты.
### Создание ответвлений (fork)
Если вы хотите вносить свой вклад в уже существующие проекты, в которых у нас нет прав
на внесения изменений путем отправки `(push)` изменений, вы можете создать свое
собственное ответвление `(“fork”)` проекта. Это означает, что `GitHub` создаст вашу
собственную копию проекта, данная копия будет находиться в вашем пространстве имен и
вы сможете легко делать изменения путем отправки `(push)` изменений.

Исторически так сложилось, что англоязычный термин `“fork”` (создание
ветвления проекта) имел негативный контекстный смысл, данный термин
означал, что кто-то повел или ведет проект с открытым исходным кодов в
другом, отличном от оригинала, направлении, иногда данный термин так же
означал создание конкурирующего проекта с раздельными авторами. В
контексте `GitHub`, `“fork”` (создание ветвления проекта) просто означает
создание ветвления проекта в собственном пространстве имен, что
позволяет вносить публичные изменения и делать свой собственный вклад в
более открытом виде.
Таким образом, проекты не обеспокоены тем, чтобы пользователи, которые хотели бы
выступать в роли соавторов, имели право на внесение изменений путем их отправки
`(push)`. Люди просто могут создавать свои собственные ветвления `(fork)`, вносить туда
изменения, а затем отправлять свои внесенные изменения в оригинальный репозиторий
проекта путем создания запроса на принятие изменений `(Pull Request)`, сами же запросы на
принятие изменений `(Pull Request)` будут описаны далее. Запрос на принятие изменений
`(Pull Request`)` откроет новую ветвь с обсуждением отправляемого кода, и автор
оригинального проекта, а так же другие его участники, могут принимать участие в
обсуждения предлагаемых изменений до тех пор, пока автор проекта не будет ими доволен,
после чего автор проекта может добавить предлагаемые изменения в проект.
Для того, чтобы создать ответвление проекта `(fork)`, зайдите на страницу проекта и
нажмите кнопку “Cоздать ответвление” `(“Fork”)`, которая расположена в правом верхнем
углу.
Через несколько секунд вы будете перенаправлены на собственную новую проектную
страницу, содержащую вашу копию, в которой у вас есть права на запись.
### Рабочий процесс с использованием GitHub
`GitHub` разработан с прицелом на определённый рабочий процесс с использованием
запросов на слияния. Этот рабочий процесс хорошо подходит всем: и маленьким,
сплочённым вокруг одного репозитория, командам; и крупным распределёным компаниям,
и группам незнакомцев, сотрудничающих над проектом с сотней копий. Рабочий процесс
`GitHub` основан на `Тематические ветки`, о которых мы Ветвление в **Git**.
Вот как это обычно работает:
1. Создайте тематическую ветку от ветки master.
2. Зафиксируйте несколько изменений, улучшающих проект.
3. Отправьте эту ветку на GitHub.
4. Откройте запрос на слияние на GitHub.
5. Обсуждайте его, вносите изменения, если нужно.
6. Владелец проекта принимает решение о принятии изменений, либо об их отклонении.
Очень напоминает подход, описанный в главе Integration-Manager Workflow, но вместо
использования электронной почты, команда сотрудничает через веб-интерфейс.
Давайте посмотрим, как можно предложить изменения в проект, размещённый на `GitHub`.
Создание запроса на слияние
Тони ищет, чего бы запустить на своём новеньком Arduino. Кажется, он нашёл классный
пример на https://github.com/schacon/blink.
Единственная проблема в том, что светодиод моргает слишком быстро; нам кажется, лучше
установить задержку в три секунды, не одну. Так давайте исправим это и предложим
изменения автору.
Для начала, нажмите кнопку `"Fork"`, как было сказано выше, чтобы заполучить
собственную копию проекта. Мы зарегистрированы на `GitHub` под именем `"tonychacon"`, так
что наша копия окажется по адресу https://github.com/tonychacon/blink, где мы сможем
редактировать её. Мы клонируем его, создадим тематическую ветку, внесём необходимые
изменения и, наконец, отправим их на `GitHub`.
```
$ git clone https://github.com/tonychacon/blink ①
Cloning into 'blink'...
$ cd blink
$ git checkout -b slow-blink ②
Switched to a new branch 'slow-blink'
$ sed -i '' 's/1000/3000/' blink.ino ③
$ git diff --word-diff ④
diff --git a/blink.ino b/blink.ino
index 15b9911..a6cc5a5 100644
--- a/blink.ino
+++ b/blink.ino
@@ -18,7 +18,7 @@ void setup() {
// the loop routine runs over and over again forever:
void loop() {
  digitalWrite(led, HIGH); // turn the LED on (HIGH is the voltage level)
  [-delay(1000);-]{+delay(3000);+} // wait for a second
  digitalWrite(led, LOW); // turn the LED off by making the voltage LOW
  [-delay(1000);-]{+delay(3000);+} // wait for a second
}
$ git commit -a -m 'three seconds is better' ⑤
[slow-blink 5ca509d] three seconds is better
 1 file changed, 2 insertions(+), 2 deletions(-)
$ git push origin slow-blink ⑥
Username for 'https://github.com': tonychacon
Password for 'https://tonychacon@github.com':
Counting objects: 5, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (3/3), 340 bytes | 0 bytes/s, done.
Total 3 (delta 1), reused 0 (delta 0)
To https://github.com/tonychacon/blink
 * [new branch] slow-blink -> slow-blink
```
① Клонируем нашу копию
② Создаём тематическую ветку
③ Вносим свои изменения
④ Проверяем изменения
⑤ Фиксируем изменения в тематической ветку
⑥ Отправляем новую ветку в нашу копию на GitHub
Теперь, если мы зайдём на страничку нашей копии на `GitHub`, мы увидим, что `GitHub`
заметил наши изменения и предлагает открыть запрос на слияние с помощью большой
`зелёной кнопки`.
Также можно зайти на страницу "Branches", по адресу
https://github.com/<user>/<project>/branches, найти интересующую ветку и открыть запрос
оттуда.
Если нажать на эту кнопку, появится экран ввода заголовка и описания предлагаемых
изменений на рассмотрение владельцу проекта. Рекомендуется серъёзно подойти к
составлению описания и сделать его максимально информативным, чтобы владелец
проекта понимал, зачем эти изменения и какую пользу они принесут.
Также мы видим список коммитов в нашей тематической ветке, "опередивших" ветку
`master` (в данном случае всего один коммит) и предпросмотр всех изменений, вносимых
этими коммитами.
После создания запроса на слияние (путём нажатия кнопки `"Create pull request"` на этой
странице) владелец форкнутого проекта получит уведомление о предложенных
изменениях со ссылкой на страницу с информацией о запросе.
Запросы на слияние широко используются для публичных проектов типа
описанного выше, когда контрибьютор уже подготовил все изменения для
слияния с основным репозиторием. Тем не менее, часто можно встретить
использование запросов на слияние во внутренних проектах в самом начале
цикла разработки. Обьяснение простое: вы можете обновлять тематическую
ветку после открытия запроса на слияние, поэтому сам запрос открывается
как можно раньше чтобы отслеживать прогресс разработки.
## Iterating on a Pull Request
На этом этапе, владелец проекта может просмореть предложенные изменения, принять,
отклонить или прокомментировать их. Предположим, ему импонирует идея, но он
предпочёл бы более долгую задержку на включение света.
В то время как в Распределенный **Git** обсуждение изменений может производится через
электронную почту, на `GitHub` всё происходит онлайн. Владелец проекта может
просмотреть суммарные изменения, вносимые запросом, и прокомментировать любую
отдельно взятую строку.
Как только владелец прокомментирует изменения, автор запроса на слияние (а также ве
подписавшиеся на этот репозиторий) получат уведомления. Далее мы рассмотрим как
настроить уведомления, но сейчас, если Тони включил уведомления через электронную
почту, он получит письмо.
Любой желающий также может оставить общие комментарии к запросу на извлечение. На странице обсуждения запроса на извлечение мы можем увидеть пример того, как владелец проекта одновременно комментирует строку кода, а затем оставляет общий комментарий в разделе обсуждения. Вы можете видеть, что комментарии к коду также включаются в диалог.
Теперь участник может видеть, что ему нужно сделать, чтобы его изменение было принято. К счастью, это тоже очень просто сделать. Там, где по электронной почте вам, возможно, придется повторно развернуть свою серию и повторно отправить ее в список рассылки, с `GitHub` вы просто снова переходите в ветку темы и нажимаете.
Если участник сделает это, то владелец проекта снова получит уведомление, и когда они посетят
страницу, они увидят, что она была адресована. На самом деле, поскольку изменилась строка кода, к которой был комментарий, `GitHub` замечает это и сворачивает устаревший `diff`.
Интересно отметить, что если вы нажмете на вкладку “Файлы изменены” в этом запросе на извлечение,вы получите “унифицированную” разницу — то есть общую совокупную разницу, которая была бы введена в вашу основную ветку, если бы эта ветка темы была объединена. В терминах `git diff` он в основном автоматически показывает вам `git diff master ... `<branch> для ветки, на которой основан этот запрос на извлечение. Смотрите Определение Того, Что Вводится для получения дополнительной информации об этом типе различий. Еще одна вещь, которую вы заметите, - это то, что `GitHub` проверяет, правильно ли выполняется слияние запроса на извлечение, и
предоставляет кнопку для выполнения слияния для вас на сервере. Эта кнопка отображается только в том случае, если у вас есть доступ на запись к репозиторию и возможно тривиальное слияние. Если вы нажмете на него, `GitHub` выполнит слияние `“без быстрой перемотки вперед”`, что означает, что даже если слияние может быть быстрым, оно все равно создаст фиксацию слияния.
Если вы предпочитаете, вы можете просто вытащить ветку вниз и объединить ее локально. Если вы объедините это перейдите в главную ветку и отправьте ее на `GitHub`, запрос на извлечение будет автоматически закрыт.
Это базовый рабочий процесс, который используется в большинстве проектов `GitHub`. Создаются тематические ветви, для них открываются запросы на извлечение, начинается обсуждение, возможно, над веткой выполняется дополнительная работа, и в конечном итоге запрос либо закрывается, либо объединяется.
Не Только Вилки
Важно отметить, что вы также можете открыть запрос на извлечение между двумя ветвями
в одном репозитории. Если вы работаете над функцией с кем-то, и у вас обоих
есть доступ на запись к проекту, вы можете поместить ветку темы в репозиторий и
открыть запрос на ее извлечение в главную ветку того же проекта, чтобы инициировать процесс
проверки и обсуждения кода. Никаких разветвлений не требуется.
## Расширенные запросы на извлечение
Теперь, когда мы рассмотрели основы участия в проекте на `GitHub`, давайте рассмотрим несколько
интересных советов и приемов, касающихся запросов на извлечение, чтобы вы могли более эффективно их использовать.
Запросы на извлечение в виде исправлений
Важно понимать, что многие проекты на самом деле не рассматривают запросы на извлечение как очереди идеальных исправлений, которые должны применяться четко по порядку, поскольку большинство проектов, основанных на списках рассылки, думают о вкладах серии исправлений. Большинство проектов `GitHub` рассматривают ветви запросов на извлечение как повторяющиеся
обсуждения предлагаемых изменений, кульминацией которых является унифицированный `diff`, применяемый путем слияния.
Это важное различие, потому что, как правило, изменение предлагается до того, как код
считается совершенным, что гораздо реже встречается с вкладами в серии исправлений на основе списков рассылки. Это позволяет провести более ранний разговор с сопровождающими, так что поиск правильного решения в большей степени зависит от усилий сообщества. Когда предлагается код с запросом на извлечение и поддержанием сопровождающие или сообщество предлагают внести изменения, серия исправлений, как правило, не выполняется повторно, но вместо этого разница
передается как новый коммит в ветку, продвигая разговор вперед с сохранением контекста
предыдущей работы.
Например, если вы вернетесь назад и снова посмотрите на `Pull Request final`, вы заметите, что участник не переназначил свою фиксацию и не отправил другой запрос на извлечение. Вместо этого они добавили новые коммиты и перенесли их в существующую ветку. Таким образом, если вы вернетесь назад и посмотрите на этот запрос на извлечение в будущем, вы можете легко найти весь контекст того, почему были приняты решения. Нажатие кнопки `“Объединить”` на сайте целенаправленно создает коммит слияния, который ссылается на запрос на извлечение, чтобы при необходимости было легко вернуться и изучить исходный диалог.
### Идти в ногу с восходящим потоком.
Если ваш запрос на извлечение устарел или иным образом не сливается чисто, вы захотите исправить это, чтобы сопровождающий мог легко объединить его. `GitHub` проверит это для вас и сообщит вам в нижней части каждого запроса на извлечение, является ли слияние тривиальным или нет.
Если вы видите что-то вроде `Pull Request` не сливается чисто, вам нужно исправить свою ветку, чтобы она стала `зеленой` и сопровождающему не пришлось выполнять дополнительную работу.
У вас есть два основных варианта для того, чтобы сделать это. Вы можете либо перебазировать свою ветвь поверх любой целевой ветви (обычно это главная ветвь репозитория, который вы разветвляли), либо вы можете объединить целевую ветвь с вашей ветвью.
Большинство разработчиков на `GitHub` предпочтут последнее по тем же причинам, которые мы только что рассмотрели в предыдущем разделе. Что важно, так это история и окончательное слияние, поэтому перебазирование не дает вам ничего, кроме немного более чистой истории, а взамен является гораздо более сложным и подверженным ошибкам.
Если вы хотите выполнить слияние в целевой ветви, чтобы сделать ваш запрос на извлечение доступным для слияния, вы должны добавить исходный репозиторий в качестве нового удаленного, извлечь из него, объединить основную ветвь этого репозитория с вашей веткой темы, исправить любые проблемы и, наконец, отправить его обратно в ту же ветку, в которой вы открыли `извлечение
Запрос включен`.
Например, предположим, что в примере `“tonychacon”`, который мы использовали ранее, автор оригинала внес изменение, которое создало бы конфликт в запросе на извлечение. Давайте пройдемся по этим шагам.
```
 git remote add upstream https://github.com/schacon/blink ①
$ git fetch upstream ②
remote: Counting objects: 3, done.
remote: Compressing objects: 100% (3/3), done.
Unpacking objects: 100% (3/3), done.
remote: Total 3 (delta 0), reused 0 (delta 0)
From https://github.com/schacon/blink
 * [new branch] master -> upstream/master
$ git merge upstream/master ③
Auto-merging blink.ino
CONFLICT (content): Merge conflict in blink.ino
Automatic merge failed; fix conflicts and then commit the result.
$ vim blink.ino ④
$ git add blink.ino
$ git commit
[slow-blink 3c8d735] Merge remote-tracking branch 'upstream/master' \
  into slower-blink
$ git push origin slow-blink ⑤
Counting objects: 6, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (6/6), done.
Writing objects: 100% (6/6), 682 bytes | 0 bytes/s, done.
Total 6 (delta 2), reused 0 (delta 0)
To https://github.com/tonychacon/blink
  ef4725c..3c8d735 slower-blink -> slow-blink
```
① Добавьте исходный репозиторий в качестве удаленного с именем “upstream”
② Извлеките самую новую работу с этого пульта дистанционного управления
③ Объедините основную ветку с веткой вашей темы
④ Исправьте возникший конфликт
⑤ Вернуться к той же ветке темы
Как только вы это сделаете, запрос на извлечение будет автоматически обновлен и повторно проверен, чтобы увидеть, сливается ли он чисто.
Одна из замечательных особенностей **Git** заключается в том, что вы можете делать это постоянно. Если у вас очень длительный проект, вы можете легко объединяться из целевой ветви снова и снова, и вам придется иметь дело только с конфликтами, возникшими с момента последнего слияния, что делает процесс очень управляемым.
Если вы абсолютно хотите перебазировать ветку, чтобы очистить ее, вы, конечно, можете это сделать, но настоятельно рекомендуется не принудительно нажимать на ветку, в которой уже открыт запрос на извлечение. Если другие люди разобрали его и проделали над ним дополнительную работу, вы столкнетесь со всеми проблемами, описанными в `Опасности перемещения`. Вместо этого переместите перебазированную ветку в новую ветку на `GitHub` и откройте
совершенно новый запрос на извлечение, ссылающийся на старую, а затем закройте исходную.
### Рекомендации.
Ваш следующий вопрос может быть: “Как мне сослаться на старый запрос на извлечение?”. Оказывается, есть много-много способов ссылаться на другие вещи практически везде, где вы можете написать в `GitHub`.
Давайте начнем с того, как сделать перекрестную ссылку на другой запрос на извлечение или проблему. Все запросы на извлечение и выпускам присваиваются номера, и они уникальны в рамках проекта. Например, вы не можете иметь извлеките запрос №3 и проблему №3. Если вы хотите сослаться на какой-либо запрос на извлечение или проблему из любого другого запроса,
вы можете просто поместить #<num> в любой комментарий или описание. Вы также можете быть более конкретны, если проблема или запрос на извлечение находятся где-то в другом месте; напишите username#<num>, если вы имеете в виду Проблему или запрос на извлечение Запрос в форке репозитория, в котором вы находитесь, или username/repo#<num> для ссылки на что-то в
другом репозитории.
Давайте рассмотрим пример. Допустим, мы перебазировали ветку в предыдущем примере, создали
для нее новый запрос на извлечение, и теперь мы хотим сослаться на старый запрос на извлечение из нового. Мы также хотим сослаться на проблему в форке репозитория и проблему в совершенно другом проекте. Мы можем заполнить описание точно так же, как перекрестные ссылки в запросе на извлечение..
Обратите внимание, что полный URL-адрес `GitHub`, который мы туда поместили, был сокращен только до необходимой информации.
Теперь, если Тони вернется назад и закроет исходный запрос на извлечение, мы увидим, что, упомянув его в новом запросе, `GitHub` автоматически создал событие отслеживания на временной шкале запроса на извлечение. Это означает, что любой, кто посещает этот запрос на извлечение и видит, что он закрыт, может легко вернуться к тому, который заменил его. Ссылка будет выглядеть примерно так, как перекрестные ссылки, отображаемые при извлечении запрос...
В дополнение к номерам выпуска вы также можете ссылаться на конкретную фиксацию с помощью `SHA-1`. Вы должны указать полный `40-символьный SHA-1`, но если `GitHub` увидит это в комментарии, он будет ссылаться непосредственно на фиксацию. Опять же, вы можете ссылаться на коммиты в форках или других репозиториях так же, как вы делали с проблемами.
### Markdown.
Ссылки на другие выпуски - это только начало интересных вещей, которые вы можете сделать практически с любым текстовым
полем на `GitHub`. В описаниях запросов на выдачу и извлечение, комментариях, комментариях к коду и многом другом вы можете использовать так называемую `“уценку со вкусом GitHub”`. Markdown - это как писать обычным текстом, но с богатой визуализацией.
Смотрите пример `Markdown` в том виде, в каком он был написан и отображен. для примера того, как комментарии или текст могут быть написаны, а затем отображены с помощью `Markdown`.
### GitHub Flavored Markdown.
Версия `Markdown` на `GitHub` добавляет больше возможностей, которые вы можете сделать, помимо базового синтаксиса `Markdown`.
Все это может быть действительно полезно при создании полезных запросов на извлечение или комментариев или описаний проблем.
### Списки задач.
Первой действительно полезной функцией `Markdown`, специфичной для `GitHub`, особенно для использования в запросах на извлечение, является `Список задач`. Список задач - это список флажков с тем, что вы хотите сделать. Включение их в запрос на выдачу или извлечение обычно указывает на то, что вы хотите сделать, прежде чем считать элемент завершенным.
Вы можете создать список задач следующим образом:
```
- [X] Write the code
- [ ] Write all the tests
- [ ] Document the code
```
Если мы включим это в описание нашего запроса на извлечение или проблемы, мы увидим, что оно отображается так же, как списки задач, отображаемые в комментарии `Markdown`.
Это часто используется в запросах на извлечение, чтобы указать, что все, что вы хотели бы сделать в ветке, прежде чем запрос на извлечение будет готов к слиянию. Самое интересное, что вы можете просто щелкнуть флажки, чтобы обновить комментарий — вам не нужно редактировать уценку напрямую, чтобы отключить задачи.
Более того, `GitHub` будет искать списки задач в ваших проблемах и извлекать запросы и показывать их в виде метаданных на страницах, на которых они перечислены. Например, если у вас есть запрос на извлечение с задачами, и вы просматриваете страницу обзора всех запросов на извлечение, вы можете увидеть, насколько он выполнен. Это помогает людям разбивать запросы на извлечение на подзадачи и помогает другим людям отслеживать ход выполнения ветки.
Вы можете увидеть пример этого в сводке списка задач в списке запросов на извлечение..
Это невероятно полезно, когда вы открываете запрос на извлечение на ранней стадии и используете его для отслеживания прогресса
в реализации функции.
`Фрагменты кода`
Вы также можете добавлять фрагменты кода в комментарии. Это особенно полезно, если вы хотите представить что-то, что вы могли бы попытаться сделать, прежде чем фактически реализовать это как коммит в вашей ветке. Это также часто используется для добавления примера кода того, что не работает или что может реализовать этот запрос на извлечение.
Чтобы добавить фрагмент кода, вы должны `”огородить"` его обратными ссылками.

```java
for(int i=0 ; i < 5 ; i++)
{
  System.out.println("i is : " + i);
}
```
Если вы добавите название языка, как мы это сделали с `java`, `GitHub` также попытается синтаксически выделить фрагмент кода. В случае приведенного выше примера это приведет к рендерингу, подобному рендерингу в примере кода..
`Цитирование`
Если вы отвечаете на небольшую часть длинного комментария, вы можете выборочно процитировать другой комментарий, поставив перед строками символ `>`. На самом деле, это настолько распространено и полезно, что для этого есть сочетание клавиш. Если вы выделите текст в комментарии, на который хотите напрямую ответить, и нажмете клавишу `r`, он процитирует этот текст в поле для комментариев.
Кавычки выглядят примерно так:
```
> Whether 'tis Nobler in the mind to suffer
> The Slings and Arrows of outrageous Fortune,
How big are these slings and in particular, these arrows?
```
## Ведение проекта.
Теперь, когда нам удобно вносить свой вклад в проект, давайте посмотрим на другую сторону: создание,сопровождение и администрирование вашего собственного проекта.
### Создание нового репозитория.
Давайте создадим новый репозиторий, чтобы поделиться с ним кодом нашего проекта. Начните с нажатия кнопки `“Создать репозиторий” “New repository”`в правой части панели мониторинга или с помощью кнопки `+` на верхней панели инструментов рядом с вашим именем пользователя, как показано в раскрывающемся списке `“Новый репозиторий”`..
`Это приведет вас к форме “новый репозиторий”`.:
Все, что вам действительно нужно здесь сделать, это указать название проекта; остальные поля совершенно необязательны. А пока просто нажмите кнопку `“Создать репозиторий”`, и бум – у вас есть новый репозиторий на `GitHub` с именем **<пользователь>/<имя_проекта>**.
Поскольку у вас там еще нет кода, `GitHub` покажет вам инструкции по созданию совершенно нового
Репозиторий **Git** или подключите существующий проект **Git**. Мы не будем обсуждать это здесь; если вам нужно обновить, ознакомьтесь с Основы **Git**.
Теперь, когда ваш проект размещен на `GitHub`, вы можете предоставить `URL-адрес` любому, с кем хотите поделиться своим проектом. Каждый проект на `GitHub` доступен по протоколу `HTTP` как
https://github.com **/<пользователь>/<имя_проекта>** и по `SS`H как `git@github.com` :**<пользователь>/<имя_проекта>**.
**Git** может извлекать данные из обоих этих `URL-адресов` и отправлять их по ним, но доступ к ним контролируется на основе учетных данных пользователя, подключающегося к ним.
Часто предпочтительнее использовать общий `URL-адрес` на основе `HTTP` для общедоступного проекта, поскольку пользователю не обязательно иметь учетную запись `GitHub`, чтобы получить к нему доступ для клонирования. Пользователи должны будут иметь учетную запись и загруженный `SSH-ключ` для доступа к вашему проекту, если вы дадите им `SSH-URL`. `HTTP-адрес` также является точно таким же `URL-адресом`, который они вставили бы в браузер, чтобы просмотреть там проект.
### Добавление сотрудников.
Если вы работаете с другими людьми, которым хотите предоставить доступ к фиксации, вам нужно добавить их в качестве `“соавторов”`. Если Бен, Джефф и Луиза зарегистрируют учетные записи на `GitHub`, и вы хотите предоставить им `push-доступ` к вашему репозиторию, вы можете добавить их в свой проект. Это даст им `“push”` доступ, что означает, что у них есть доступ как на чтение, так и на запись к проекту и репозиторию **Git**.
Нажмите на ссылку `“Настройки” “Settings”` в нижней части правой боковой панели.
Затем выберите `“Соавторы”“Collaborators”` в меню слева. Затем просто введите имя пользователя в
поле и нажмите `“Добавить сотрудника” “Add collaborator.”`. Вы можете повторять это столько раз, сколько захотите, чтобы предоставить доступ всем, кто вам нравится. Если вам нужно отозвать доступ, просто нажмите `“X”` в правой части их
строки.
### Управление запросами на извлечение Managing Pull Requests.
Теперь, когда у вас есть проект с некоторым кодом и, возможно, даже несколько сотрудников, у которых также есть `push-доступ`, давайте рассмотрим, что делать, когда вы сами получаете запрос на извлечение.
Запросы на извлечение могут поступать либо из ветки в `форке вашего репозитория`, либо из
другой ветки в том же репозитории. Единственная разница заключается в том, что те, что находятся в `форке`, часто исходят от людей, которых вы не можете подтолкнуть к их ветке, а они не могут подтолкнуть к вашей, тогда как с внутренней `запросы на извлечение` обычно обе стороны могут получить доступ к ветке.
Для этих примеров давайте предположим, что вы `“tonychacon”` и создали новый проект кода
**Arudino** под названием `“fade”`.
`**Уведомления по электронной почте**`
Кто-то приходит, вносит изменения в ваш код и отправляет вам запрос на извлечение. Вы должны
получить электронное письмо с уведомлением о новом запросе на извлечение, и оно должно выглядеть примерно как уведомление по электронной почте о новом запросе на извлечение..
Есть несколько вещей, на которые следует обратить внимание в этом электронном письме. Это даст вам небольшой `diffstat` — список файлов, которые
изменились в запросе на извлечение и на сколько. Это дает вам ссылку на запрос на извлечение на
`GitHub`. Он также предоставляет вам несколько `URL-адресов`, которые вы можете использовать из командной строки.
Если вы заметили строку с надписью `git pull` <url> `patch-1`, это простой способ объединить удаленную ветку без необходимости добавления удаленного. Мы быстро рассмотрели это при проверке удаленных ветви. При желании вы можете создать ветку темы и переключиться на нее, а затем выполнить эту команду для объединения изменений в запросе на извлечение.
Другими интересными `URL-адресами` являются `URL-адреса .diff` и `.patch`, которые, как вы можете догадаться, предоставляют унифицированные версии `diff` и `patch` запроса на извлечение. Технически вы могли бы объединить работу с запросом на извлечение с чем-то вроде этого:
```
curl http://github.com/tonychacon/fade/pull/1.patch | git am
```
### Совместная работа над запросом на извлечение. Collaborating on the Pull Request.
Как мы уже рассказывали в `Рабочий процесс с использованием GitHub`, теперь вы можете поговорить
с человеком, который открыл запрос на извлечение. Вы можете комментировать определенные строки кода, комментировать целые коммиты или комментировать весь сам запрос на извлечение, используя везде уценку со вкусом `GitHub`.
Каждый раз, когда кто-то другой комментирует запрос на извлечение, вы будете продолжать получать уведомления по электронной почте, чтобы знать, что происходит какая-то активность. У каждого из них будет ссылка на запрос на извлечение, в котором выполняется действие, и вы также можете напрямую ответить на электронное письмо, чтобы прокомментировать поток запроса на извлечение.
Как только код окажется в понравившемся вам месте и вы захотите его объединить, вы можете либо вытащить код и объединить его локально, либо с помощью синтаксиса `git pull` <url> <branch>, который мы видели ранее, либо добавив `fork` в качестве удаленного и извлекая и объединяя.
Если слияние тривиально, вы также можете просто нажать кнопку `“Объединить”` на сайте `GitHub`. Это приведет к слиянию `“без быстрой перемотки вперед”`, создавая фиксацию слияния, даже если слияние с быстрой перемоткой вперед было возможно. Это означает, что, несмотря ни на что, каждый раз, когда вы нажимаете кнопку `слияния`, создается фиксация слияния. Как вы
можете видеть в разделе `Кнопка слияния` и инструкции по объединению запроса на извлечение вручную., `GitHub` предоставит вам всю эту информацию, если вы нажмете на ссылку подсказки.
Если вы решите, что не хотите его объединять, вы также можете просто закрыть запрос на извлечение, и человек, который его открыл, получит уведомление.
### Ссылки на запросы на вытягивание Pull Request Refs.
Если вы имеете дело с большим количеством запросов на извлечение и не хотите добавлять кучу пультов дистанционного управления или каждый раз выполнять однократное извлечение, есть изящный трюк, который позволяет вам сделать `GitHub`. Это довольно сложный
трюк, и мы рассмотрим его подробнее в `Спецификации ссылок`, но он может быть довольно
полезным.
`GitHub` фактически рекламирует ветви запроса на извлечение для репозитория как своего рода псевдо-ветви на сервере. По умолчанию вы не получаете их при клонировании, но они есть в скрытом виде, и вы можете довольно легко получить к ним доступ. 
Чтобы продемонстрировать это, мы собираемся использовать команду низкого уровня (часто называемую `“сантехникой”`). Команда, о которой мы подробнее поговорим в `Сантехника` и `Фарфор`) называется `ls-remote`. Эта команда обычно не используется в повседневных операциях **Git**, но она полезна, чтобы показать нам, какие ссылки присутствуют на сервере.
Если мы выполним эту команду для репозитория `“blink”`, который мы использовали ранее, мы получим список всех ветвей, тегов и других ссылок в репозитории.
```
git ls-remote https://github.com/schacon/blink
10d539600d86723087810ec636870a504f4fee4d HEAD
10d539600d86723087810ec636870a504f4fee4d refs/heads/master
6a83107c62950be9453aac297bb0193fd743cd6e refs/pull/1/head
afe83c2d1a70674c9505cc1d8b7d380d5e076ed3 refs/pull/1/merge
3c8d735ee16296c242be7a9742ebfbc2665adec1 refs/pull/2/head
15c9f4f80973a2758462ab2066b6ad9fe8dcf03d refs/pull/2/merge
a5a7751a33b7e86c5e9bb07b26001bb17d775d1a refs/pull/4/head
31a45fc257e8433c8d8804e3e848cf61c9d3166c refs/pull/4/merge
```
Конечно, если вы находитесь в своем репозитории и запускаете `git ls-remote origin` или любой другой удаленный сервер, который вы хотите проверить, он покажет вам что-то похожее на это.
Если репозиторий находится на `GitHub` и у вас есть какие-либо открытые запросы на извлечение, вы получите эти ссылки с префиксом `refs/pull/`. По сути, это ветви, но поскольку они
не находятся в разделе `refs / heads /`, вы обычно не получаете их при клонировании или извлечении с сервера — процесс извлечения обычно игнорирует их.
Для каждого запроса на извлечение есть две ссылки - та, которая заканчивается на `/head`, указывает точно на ту же фиксацию, что и последняя фиксация в ветке запроса на извлечение. Итак, если кто-то откроет запрос на извлечение в нашем репозитории, и его ветвь называется `bug-fix` и указывает на фиксацию `a5a775`, то в нашем репозитории у нас не будет ветки с исправлением ошибок (поскольку она находится в их форке), но у нас будет` pull /` <pr#>`/head`, которая указывает на `a5a775`. Это означает, что мы можем довольно легко удалить каждую ветку запроса на извлечение за один раз без необходимости добавлять кучу пультов дистанционного управления.
Теперь вы могли бы сделать что-то вроде прямой выборки ссылки.
```
git fetch origin refs/pull/958/head
From https://github.com/libgit2/libgit2
 * branch refs/pull/958/head -> FETCH_HEAD
```
Это говорит **Git**: “Подключитесь к удаленному источнику и загрузите ссылку с именем `refs / pull /958 /head`”. **Git** с радостью повинуется и загружает все, что вам нужно для создания этой ссылки, и помещает указатель на нужную фиксацию в `.git /FETCH_HEAD`. Вы можете выполнить это с помощью `git merge FETCH_HEAD` в ветку, в которой вы хотите ее протестировать, но это сообщение о фиксации слияния выглядит немного странно. Кроме того, если вы просматриваете много запросов на извлечение, это становится утомительным.
Существует также способ получать все запросы на извлечение и обновлять их всякий раз, когда вы подключаетесь к удаленному устройству. Откройте файл `.git/config` в вашем любимом редакторе и найдите исходный пульт дистанционного управления. Это должно выглядит примерно так:
```
[remote "origin"]
  url = https://github.com/libgit2/libgit2
  fetch = +refs/heads/*:refs/remotes/origin/*
```
Та строка, которая начинается с `fetch =`, является `“refspec”`. Это способ сопоставления имен на удаленном компьютере с именами в вашем локальном каталоге `.git`. Этот конкретный говорит **Git**: "Вещи на удаленном компьютере, которые находятся в разделе `refs /heads`, должны находиться в моем локальном репозитории в разделе `refs /remotes /origin`". Вы можете изменить этот раздел, чтобы добавить еще одну ссылку:
```
[remote "origin"]
  url = https://github.com/libgit2/libgit2.git
  fetch = +refs/heads/*:refs/remotes/origin/*
  fetch = +refs/pull/*/head:refs/remotes/origin/pr/*
```
Эта последняя строка сообщает **Git**: `“Все ссылки, которые выглядят как ссылки / pull /123 /head, должны храниться локально, как ссылки / remotes /origin /pr /123”`. Теперь, если вы сохраните этот файл и выполните `git-выборку`:
```
git fetch
# …
 * [new ref] refs/pull/1/head -> origin/pr/1
 * [new ref] refs/pull/2/head -> origin/pr/2
 * [new ref] refs/pull/4/head -> origin/pr/4
# …
```
Теперь все удаленные запросы на извлечение представлены локально с помощью ссылок, которые действуют очень похоже на отслеживание ветвей; они доступны только для чтения и обновляются, когда вы выполняете выборку. Это позволяет очень легко попробовать код из запроса на извлечение локально:
```
git checkout pr/2
Checking out files: 100% (3769/3769), done.
Branch pr/2 set up to track remote branch pr/2 from origin.
Switched to a new branch 'pr/2'
```
Те из вас, у кого зоркий взгляд, обратили бы внимание на головку на конце удаленной части спецификации. На стороне `GitHub` также есть ссылка `refs /pull / #/merge`, которая представляет фиксацию, которая произойдет, если вы нажмете кнопку `“объединить”` на сайте. Это может позволить вам протестировать слияние еще до того, как вы нажмете кнопку.
### Запросы на извлечение по запросам на извлечение Pull Requests on Pull Requests.
Вы можете не только открывать запросы на извлечение, нацеленные на основную или главную ветвь, но и фактически открывать `Запрос на извлечение`, нацеленный на любую ветку в сети. На самом деле, вы даже можете настроить таргетинг на другой запрос на извлечение.
Если вы видите запрос на извлечение, который движется в правильном направлении, и у вас есть идея для изменения, которое зависит от него, или вы не уверены, что это хорошая идея, или у вас просто нет `push-доступа` к целевой ветке, вы можете открыть запрос на извлечение непосредственно к нему.
Когда вы переходите к открытию запроса на извлечение, в верхней части страницы появляется поле, в котором указывается, в какую ветвь вы запрашиваете извлечение и из какой вы запрашиваете извлечение. Если вы нажмете кнопку `“Редактировать” “Edit”` справа от этого поля, вы сможете изменить не только ветви, но и то, какая именно ветвь.
Здесь вы можете довольно легко указать, чтобы объединить вашу новую ветвь с другим запросом на извлечение или другим `форком проекта`.
### Упоминания и уведомления.
В `GitHub` также встроена довольно приятная система уведомлений, которая может пригодиться, когда у вас есть вопросы или нужна обратная связь от конкретных людей или команд.
В любом комментарии вы можете начать вводить символ `@`, и он начнет автоматически заполняться именами и именами пользователей людей, которые являются соавторами или участниками проекта.
Вы также можете указать пользователя, которого нет в этом выпадающем списке, но часто автозаполнение может ускорить это.
Как только вы опубликуете комментарий с упоминанием пользователя, этот пользователь будет уведомлен. Это означает, что это может быть действительно эффективным способом вовлечения людей в разговоры, а не заставлять их опрашивать. Очень часто в запросах на извлечение на `GitHub` люди привлекают других людей из своих команд или в своей компании для рассмотрения Проблемы или запроса на извлечение.
Если кто-то будет упомянут в запросе на извлечение или проблеме, он будет `“подписан”` на него и будет продолжать получать уведомления каждый раз, когда на нем происходит какое-либо действие. Вы также будете подписаны на что-то, если вы его открыли, если вы просматриваете репозиторий или если вы что-то комментируете. Если вы больше не хотите получать уведомления, на странице есть кнопка `“Отказаться от подписки”`, которую вы можете нажать, чтобы прекратить получать обновления на ней.
### Страница Уведомлений.
Когда мы упоминаем здесь `“уведомления”` в отношении `GitHub`, мы имеем в виду конкретный способ, которым `GitHub` пытается связаться с вами, когда происходят события, и есть несколько различных способов, которыми вы можете их настроить. Если вы перейдете на вкладку `“Центр уведомлений”` со страницы настроек, вы сможете увидеть некоторые из имеющихся у вас опций.
Два варианта - получать уведомления по `“электронной почте”` и через `“Интернет”`, и вы можете выбрать либо то, либо другое, либо и то, и другое, когда вы активно участвуете в мероприятиях и за активностью в репозиториях, которые вы просматриваете. `Веб-уведомления`
Веб-уведомления существуют только на `GitHub`, и вы можете проверить их только на `GitHub`. Если у вас выбран этот параметр в настройках и для вас запускается уведомление, вы увидите маленькую синюю точку над значком уведомлений в верхней части экрана, как показано в центре уведомлений..
Если вы нажмете на это, вы увидите список всех элементов, о которых вы были уведомлены, сгруппированных по проектам. Вы можете отфильтровать уведомления по конкретному проекту, нажав на его название на левой боковой панели. Вы также можете подтвердить получение уведомления, щелкнув значок галочки рядом с любым уведомление или подтвердите все уведомления в проекте, щелкнув галочку в верхней части группы. Рядом с каждой галочкой также есть кнопка отключения звука, которую вы можете нажать, чтобы больше не получать
никаких уведомлений по этому элементу.
Все эти инструменты очень полезны для обработки большого количества уведомлений. Многие опытные
пользователи `GitHub` просто полностью отключают уведомления по электронной почте и управляют всеми своими уведомлениями через этот экран.
### Уведомления по электронной почте.
Уведомления по электронной почте - это еще один способ обработки уведомлений через `GitHub`. Если у вас это включено, вы будете получать электронные письма для каждого уведомления. Мы видели примеры этого в Комментарии, отправленные по электронной почте и уведомлении по электронной почте о новом запросе на извлечение.. Электронные письма также будут обрабатываться должным образом, что хорошо, если вы используете потоковый почтовый клиент.
Существует также изрядное количество метаданных, встроенных в заголовки электронных писем, которые отправляет вам `GitHub`, что может быть действительно полезно для настройки пользовательских фильтров и правил.
Например, если мы посмотрим на фактические заголовки электронных писем, отправленных Тони в электронном письме, показанном в уведомлении по электронной почте о новом запросе на извлечение., мы увидим следующее среди отправленной информации:
```
To: tonychacon/fade <fade@noreply.github.com>
Message-ID: <tonychacon/fade/pull/1@github.com>
Subject: [fade] Wait longer to see the dimming effect better (#1)
X-GitHub-Recipient: tonychacon
List-ID: tonychacon/fade <fade.tonychacon.github.com>
List-Archive: https://github.com/tonychacon/fade
List-Post: <mailto:reply+i-4XXX@reply.github.com>
List-Unsubscribe: <mailto:unsub+i-XXX@reply.github.com>,...
X-GitHub-Recipient-Address: tchacon@example.com
```
Здесь есть пара интересных вещей. Если вы хотите выделить или перенаправить электронные письма на этот конкретный проект или даже отправить запрос, информация в Message-ID предоставляет вам все данные в формате <user>/<project>/<type>/<id>. Если бы это было проблемой, например, поле <тип> было бы
`“проблемы”`, а не `“вытащить”`.
Поля `List-Post` и `List-Unsubscribe` означают, что если у вас есть почтовый клиент, который их понимает, вы можете легко опубликовать в списке или `“Отписаться”` от темы. Это было бы по сути тоже самое, что нажать кнопку `“Отключить звук”` в веб-версии уведомления или `“Отказаться от подписки”` на самой странице вопроса или запроса на получение.
Также стоит отметить, что если у вас включены как уведомления по электронной почте, так и веб-уведомления, и вы читаете электронную версию уведомления, веб-версия также будет помечена как прочитанная, если в вашем почтовом клиенте разрешены изображения.
**Специальные Файлы**
Есть несколько специальных файлов, которые `GitHub` заметит, если они присутствуют в вашем репозитории.
### ПРОЧИТАЙ МЕНЯ README.
Первый - это файл `README`, который может быть практически любого формата, который `GitHub` распознает как `prose`. 
Например, это может быть `README`, `README.md` , `README.asciidoc` и т.д. Если `G`itHub` увидит файл `README` в вашем исходном коде, он отобразит его на целевой странице проекта.
Многие команды используют этот файл для хранения всей необходимой информации о проекте для тех, кто может быть новичком в репозитории или проекте. Обычно это включает в себя такие вещи, как:
• Для чего предназначен проект
• Как настроить и установить его
• Пример того, как его использовать или запустить
• Лицензия, по которой предлагается проект
• Как внести в это свой вклад
Поскольку `GitHub` будет отображать этот файл, вы можете вставлять в него изображения или ссылки для дополнительного удобства
понимания.
### Cпособствующий. 
Другим специальным файлом, который распознает `GitHub`, является файл `CONTRIBUTING`. Если у вас есть файл с именем `ВНОСЯ` вклад с любым расширением файла, `GitHub` покажет открытие запроса на извлечение, когда `СООТВЕТСТВУЮЩИЙ` файл существует. когда кто-либо начинает открывать запрос на извлечение.












































  






